<templateSet group="Algorithm">
  <template name="oytreepreorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    // 节点的基本构造&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 递归前序遍历&#10;    public static void preOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        System.out.print(head.value + &quot; &quot;);&#10;        preOrderRecur(head.left);&#10;        preOrderRecur(head.right);&#10;    }&#10;&#10;    // 非递归前序遍历&#10;    public static void preOrderUnRecur(Node head) {&#10;        System.out.print(&quot;pre-order: &quot;);&#10;        if (head != null) {&#10;            // 采用栈结构&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            stack.add(head);&#10;            while (!stack.isEmpty()) {&#10;                // 这里的head是复用的，表示当前节点&#10;                head = stack.pop();&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 整体的顺序是先压右后压左&#10;                if (head.right != null) {&#10;                    stack.push(head.right);&#10;                }&#10;                if (head.left != null) {&#10;                    stack.push(head.left);&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 前序遍历 - OYTreePreOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeinorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    //递归&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        System.out.print(head.value + &quot; &quot;);&#10;        inOrderRecur(head.right);&#10;    }&#10;&#10;    //非递归&#10;    public static void inOrderUnRecur(Node head) {&#10;        System.out.print(&quot;in-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();//左根右&#10;            //！stack.isEmpty这个条件只是用来判断是否结束而已，关键的是head != null这个条件&#10;            while (!stack.isEmpty() || head != null) {&#10;                //如果当前节点不为空将当前节点压入栈然后当前节点往左;当前节点为空从栈拿一个打印，然后当前节点往右边跑&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                } else {&#10;                    //把当前节点指向了从栈弹出的那个节点&#10;                    head = stack.pop();&#10;                    System.out.print(head.value + &quot; &quot;);&#10;                    head = head.right;&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 中序遍历 - OYTreeInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeposorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        inOrderRecur(head.right);&#10;        System.out.print(head.value + &quot; &quot;);&#10;    }&#10;&#10;    public static void posOrderUnRecur1(Node head) {&#10;        System.out.print(&quot;pos-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();&#10;            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();&#10;            s1.push(head);&#10;            while (!s1.isEmpty()) {&#10;                head = s1.pop();&#10;                s2.push(head);&#10;                //本来是打印的时机，但你先不打印全部先放到辅助栈s2&#10;                if (head.left != null) {&#10;                    s1.push(head.left);&#10;                }&#10;                if (head.right != null) {&#10;                    s1.push(head.right);&#10;                }&#10;            }&#10;            //再打印栈s2&#10;            while (!s2.isEmpty()) {&#10;                System.out.print(s2.pop().value + &quot; &quot;);&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 后序遍历 -OYTreePosOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreelevelorder" value="public class Solution {&#10;    public static class Node {&#10;        int  value;&#10;        Node left;&#10;        Node right;&#10;&#10;        public Node(int data){&#10;            this.value = data;&#10;        }&#10;    }&#10;    &#10;    public static void levelRead(Node head) {&#10;        // 当结点非空时才进行操作&#10;        if (head != null) {&#10;            // 用于存放还未遍历的元素&#10;            LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();&#10;            // 将根结点入队&#10;            queue.add(head);&#10;            // 用于记录当前处理的结点&#10;            //Node head;&#10;&#10;            // 队列非空则进行处理&#10;            while (!queue.isEmpty()) {&#10;                // remove()表示删除队首元素&#10;                head = queue.remove();&#10;                // 输出队首元素的值&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 如果左子结点不为空，则左子结点入队&#10;                if (head.left != null) {&#10;                    queue.add(head.left);&#10;                }&#10;                // 如果右子结点不为空，则左子结点入队&#10;                if (head.right != null) {&#10;                    queue.add(head.right);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" description="二叉树 -  层序遍历 -OYTreeLevelOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgebalance" value="/*&#10; * 判断一颗二叉树是否是平衡二叉树，它是一棵空树或任意节点左右两个子树的高度差的绝对值不超过1称为平衡二叉树&#10; *&#10; * 这道题目充分体现了递归对于解决树相关算法题的作用,如果我们抛开先序中序后序的打印时机,其实递归来到每个节点的次数是三次&#10; * 我既然可以回到要给节点三次,我们就可以收集左子树和右子树的信息,最后回到根节点,进行判断,可以总结为一个高度解题套路&#10; * 譬如我为了判断X为根节点的树是不是平衡树,我们可以先判断节点X的左树是否平衡,右树是否平衡,然后获取左树高度和右树高度比较是否超过1&#10; * 套路就是要设计我们的递归返回结构,对于这道题来说我们需要递归函数给我们返回信息包括了这棵树是否平衡和这棵树高度;&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 设计递归的返回结构&#10;    public static class ReturnData{&#10;        // 是否是平衡二叉树&#10;        public boolean isBalance;&#10;        // 树的高度&#10;        public int height;&#10;&#10;        public ReturnData(boolean isBalance,int height){&#10;            this.isBalance = isBalance;&#10;            this.height = height;&#10;        }&#10;    }&#10;&#10;    public static boolean isBalanceTree(Node head) {&#10;        return process(head).isBalance;&#10;    }&#10;&#10;    // 设计递归函数,返回信息包括该树是否是平衡二叉树以及该树的高度&#10;    public static ReturnData process(Node head){&#10;        // 如果是空树认为也算是平衡二叉树&#10;        if(head == null){&#10;            return new ReturnData(true,0);&#10;        }&#10;        ReturnData leftData = process(head.left);&#10;        // 如果左树已经是不平衡直接返回不平衡&#10;        if(!leftData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        ReturnData rightData = process(head.right);&#10;        // 如果右树已经是不平衡直接返回不平衡&#10;        if(!rightData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // 说明左树和右树都已经平衡了&#10;        if(Math.abs(leftData.height - rightData.height) &gt; 1){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // return在递归中很重要,左树和右树高度较大的那个加1就是我自己的高度&#10;        return new ReturnData(true,Math.max(leftData.height , rightData.height) + 1);&#10;    }&#10;&#10;}&#10;" description="二叉树 - 判断平衡二叉树 - OYTreeJudgeBalance" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreefindbehindnode" value="import java.util.*;&#10;&#10;/* 解题规律:&#10; * 1.首先我们要明白后继节点值得是,在二叉树终须遍历序列中,node的下一个节点叫做node的后继节点&#10; * 2.如果节点X有右子树,那么该节点的后继节点一定是其右子树最左的节点(结合中序遍历思考得出);&#10; * 3.如果节点X没有右子树，通过节点X的Parent指针找节点X的父节点,一直往上找，直到节点X是该某个节点的左孩子，那么这个某个节点就是X节点的后继节点&#10; */&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;        public Node parent;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static Node getSuccessorNode(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;&#10;        if (node.right != null) {&#10;            //如果一个节点有右子树,直接找到这颗右子树上最左的节点&#10;            return getLeftMost(node.right);&#10;        } else {&#10;            Node parent = node.parent;&#10;            //parent != null处理边界值，parent.left != node当前节点等于自己的左孩子停&#10;            while (parent != null &amp;&amp; parent.left != node) {&#10;                node = parent;&#10;                parent = node.parent;&#10;            }&#10;            return parent;&#10;        }&#10;    }&#10;&#10;    //拿到右子树上最左的节点&#10;    public static Node getLeftMost(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;        while (node.left != null) {&#10;            node = node.left;&#10;        }&#10;        return node;&#10;    }&#10;}" description="二叉树 - 查找后继节点 - OYTreeFindBehindNode" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgesearch" value="import java.util.*;&#10;&#10;/*&#10; * 判断一棵树是否是搜索二叉树，左子树值比自己小，右子树值比自己大。其实只要满足二叉树中序遍历结果是依次升序的就是搜索二叉树&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean inOrderUnRecur(Node head) {&#10;        if (head != null) {&#10;            int pre = 0;&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            while(!stack.isEmpty() || head != null) {&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                }else {&#10;                    stack.pop();&#10;                    // 当前这个数是否比前一个数小则不满足搜索二叉树&#10;                    if (head.value &lt; pre){&#10;                        return false;&#10;                    }&#10;                    head = head.right;&#10;                }&#10;            }&#10;            return true;&#10;        }&#10;    }&#10;}" description="二叉树 - 判断搜索二叉树 - OYTreeJudgeSearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgecomplete" value="import java.util.*;&#10;&#10;/* 如何判断一个数是否是完全二叉树,按层一个节点一个节点遍历,每个节点需要满足下面两个条件&#10; * 第一阶段：如果一个节点只有右孩子没有左孩子绝对不是完全二叉树,可以直接返回false&#10; * 第二阶段：如果一个节点不是左右两个孩子都全(那么这里要么是有左孩子没有右孩子要么是左右都没有孩子)，&#10; *         那么在这样的情况下按层遍历如果未遍历的节点都是叶子节点则说明是完全二叉树&#10; */&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean isCompleteBinaryTree(Node head) {&#10;        if (head == null) {&#10;            return true;&#10;        }&#10;        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();&#10;        //标志是否进入了第二阶段，开启后续节点都是叶节点的这样一个阶段&#10;        boolean leaf = false;&#10;        Node l = null;&#10;        Node r = null;&#10;        queue.offer(head);&#10;        while (!queue.isEmpty()) {&#10;            head = queue.poll();&#10;            l = head.left;&#10;            r = head.right;&#10;            //这个if语句中有两个判断条件：&#10;            //第一个条件：如果我开启了第二阶段了 并且左孩子不为空或者右孩子不为空 (标准二)&#10;            //第二个条件：左孩子为空，右孩子也不为空(标准一)&#10;            if ((leaf &amp;&amp; (l != null || r != null))&#10;                    ||&#10;                    (l == null &amp;&amp; r != null)){&#10;                return false;&#10;            }&#10;            if (l != null) {&#10;                queue.offer(l);&#10;            }&#10;            if (r != null) {&#10;                queue.offer(r);&#10;            }&#10;            if (l == null || r == null) {&#10;                //进入第二阶段&#10;                leaf = true;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="二叉树 - 判断完全二叉树 - OYTreeJudgeComplete" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortbubble" value="public class Solution {&#10;    public static void bubbleSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;&#10;        for (int end = arr.length -1; end &gt; 0; end--){&#10;            //设置这一趟并未发生交换&#10;            boolean exchange = false;&#10;            for (int i = 0; i &lt; end; i++){&#10;                if (arr[i] &gt; arr[i+1]){&#10;                    swap(arr, i, i + 1);&#10;                    //已经发生交换&#10;                    exchange = true;&#10;                }&#10;            }&#10;            //如果没有发生交换则break说明前面都已经排序完毕，节省没必要的比较&#10;            if (!exchange) break;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 冒泡排序 - OYArraySortBubble" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortselection" value="public class Solution {&#10;    public static void selectionSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        //i &lt; length - 1数组的最后一位没有必要再进行比较&#10;        for (int i = 0; i &lt; arr.length - 1; i++){&#10;            //我定义的最小值的Index&#10;            int minIndex = i;&#10;            //这里就可以说j对于i是不变的，虽然i是变的；j其实是每一趟的起始值&#10;            for (int j = i + 1;j &lt; arr.length;j++){&#10;                //实际找到的minIndex&#10;                minIndex = arr[j] &lt; arr[minIndex] ? j:minIndex;&#10;            }&#10;            swap(arr, i, minIndex);&#10;        }&#10;    }&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;    //打印数组的每一个元素出来&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);//这里加空格&#10;        }&#10;        //下面这句总体换一行，细节真的很关键&#10;        System.out.println();&#10;    }&#10;}" description="数组 - 选择排序 - OYArraySortSelection" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortinsert" value="public class Solution {&#10;    public static void insertSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        for (int i = 1; i &lt; arr.length; i++) {&#10;            //就像打扑克牌排序一样插入排序，一张牌来了，从右往左遍历&#10;            for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {&#10;                swap(arr, j, j + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 插入排序 - OYArraySortInsert" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortmerge" value="public class Solution {&#10;    public static void mergeSort(int[] arr){&#10;        if (arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int l,int r){&#10;        if(l == r){&#10;            return;&#10;        }&#10;        int mid = l + ((r - l) &gt;&gt; 1);&#10;        mergeSort(arr, l, mid);&#10;        mergeSort(arr, mid+1, r);&#10;        merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static void merge(int[] arr, int l, int m, int r){&#10;        int[] help = new int[r - l + 1];&#10;        int i = 0;&#10;        int p1 = l;&#10;        int p2 = m + 1;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r){&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        while (p1 &lt;= m){&#10;            help[i++] = arr[p1++];&#10;        }&#10;        while (p2 &lt;= r){&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++){&#10;            arr[l + i] = help[i];&#10;        }&#10;    }&#10;}&#10;" description="数组 - 归并排序 - OYArraySortMerge" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortquick" value="public class Solution {&#10;    public static void quickSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        quickSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void quickSort(int[] arr, int L, int R) {&#10;        //这个条件很重要,整个过程必须要在L&lt;R下进行&#10;        if (L &lt; R) {&#10;            //随机选择一个数和最后一个数交换，然后采用最后一位数做标志位&#10;            swap(arr, L + (int) (Math.random() * (R - L + 1)), R);&#10;            int[] p = partition(arr, L, R);&#10;            //递归遍历,每次确定中间的一片数字&#10;            quickSort(arr, L, p[0] - 1);&#10;            quickSort(arr, p[1] + 1, R);&#10;        }&#10;    }&#10;&#10;    public static int[] partition(int[] arr, int L, int R) {&#10;        //数组第零位的前面一位,这里复用了L变量而已&#10;        int less = L - 1;&#10;        //把数组的最后一位当成了Partition问题中的比较数字&#10;        int more = R;&#10;&#10;        while (L &lt; more) {&#10;            if (arr[L] &lt; arr[R]) {&#10;                swap(arr, ++less, L++);&#10;            } else if (arr[L] &gt; arr[R]) {&#10;                swap(arr, --more, L);&#10;            } else {&#10;                L++;&#10;            }&#10;        }&#10;        //因为最后一位并没有参与遍历此时数组的划分为 &lt;X | =X | &gt;X | X 四个区域&#10;        //为此我们要通过swap函数交换为 &lt;X | =X | &gt;X 三个区域&#10;        swap(arr, more, R);&#10;        //返回等于区域相应的下标&#10;        return new int[] { less + 1, more };&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}&#10;" description="数组 - 快速排序 - OYArraySortQuick" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortHeap" value="import java.util.Arrays;&#10;&#10;&#10;public class Solution {&#10;&#10;    public static void heapSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        // 下面这一步后整个数组就是大根堆结构了&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            // 依次把i位置上的数加进来，让他从0-i位置上称为大根堆&#10;            heapInsert(arr, i);&#10;        }&#10;        int heapSize = arr.length;&#10;&#10;        // 将堆顶与堆底最后一个数字交换&#10;        swap(arr, 0, --heapSize);&#10;&#10;        while (heapSize &gt; 0) {&#10;            // 每次都修正整个堆，让堆顶是最大的数字&#10;            heapify(arr, 0, heapSize);&#10;            // 将堆顶与heapSize最后一个数交换,每次交换都缩小heapSize的范围，将已经排序完毕的数字排出去&#10;            swap(arr, 0, --heapSize);&#10;        }&#10;    }&#10;&#10;    //建立大根堆,把数组变为大根堆结构,index表示即将要加进来的节点&#10;    public static void heapInsert(int[] arr, int index) {&#10;        // while循环将子节点比父节点大的节点提上来&#10;        while (arr[index] &gt; arr[(index - 1) / 2]) {&#10;            // 当前我比我的父位置要大，则交换&#10;            swap(arr, index, (index - 1) / 2);&#10;            // 交换完之后继续与父位置进行比较直到满足大根堆&#10;            // 此处精妙之处在于当节点一直跳到最顶的节点那么会变成arr[0]与arr[(0-1)/2]比较，则必定相等跳出循环&#10;            index = (index - 1) / 2;&#10;        }&#10;    }&#10;&#10;    // 修正数组为堆结构,这个函数的意思是在0 ~ heapSize-1我认为形成了堆，除了这个范围我认为越界；&#10;    // index的值发生了变小了，导致index这个节点应该往下沉&#10;    // heapSize的意思是整个堆上有多少个数，与数组个数并没有关系，但一定不会比数组个数大；&#10;    public static void heapify(int[] arr, int index, int heapSize) {&#10;        int left = index * 2 + 1;&#10;        //while成立条件是我的左还是还在堆上&#10;        while (left &lt; heapSize) {&#10;            //找出左右节点最大值的下标，left + 1表示右孩子;只有你有右孩子并且右孩子比左孩子要大那么largest才是右孩子&#10;            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left]&#10;                    ? left + 1&#10;                    : left;&#10;            //找到左右节点最大值与父节点比较找到最大值下标，并将其作为largest&#10;            largest = arr[largest] &gt; arr[index] ? largest : index;&#10;            //如果发现最大值是自己则不需要交换break&#10;            if (largest == index) {&#10;                break;&#10;            }&#10;            //largest != index&#10;            swap(arr, largest, index);&#10;            index = largest;&#10;            //left又往下走重复整个while循环&#10;            left = index * 2 + 1;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 堆排序 - OYArraySortHeap" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraynixudui" value="public class Solution {&#10;    public static void niXuDui(int[] arr) {&#10;        if(arr == null || arr.length &lt; 2)&#10;            return;&#10;&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int L, int R) {&#10;        if(L == R) {&#10;            return;&#10;        }&#10;&#10;        int mid = L + (R - L) / 2;&#10;        mergeSort(arr, L, mid);&#10;        mergeSort(arr, mid + 1, R);&#10;        merge(arr, L, mid, R);&#10;    }&#10;&#10;    public static void merge(int[] arr, int L, int m, int R) {&#10;        int[] help = new int[R - L + 1];&#10;        int i = 0;&#10;        int p1 = L;&#10;        int p2 = m + 1;&#10;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= R) {&#10;            // 如果这个条件成立，那么左半部分的所有数一定大于右半部分&#10;            if(arr[p1] &gt; arr[p2]) {&#10;                for(int j = p1; j &lt;= m; j++) {&#10;                    System.out.println(arr[j] + &quot;, &quot; + arr[p2]);&#10;                }&#10;            }&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;&#10;        while (p2 &lt;= R) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++) {&#10;            arr[L + i] = help[i];&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] a = {1, 3, 4, 2, 5};&#10;        niXuDui(a);&#10;&#10;    }&#10;}" description="数组 - 归并衍生的逆序对 - OYArrayMergenixudui" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraymergeminsum" value="public class Solution {&#10;    public static int smallSum(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        return mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static int mergeSort(int[] arr, int l, int r) {&#10;        if (l == r) {&#10;            return 0;&#10;        }&#10;        int mid = l + (r - l) &gt;&gt; 1;&#10;        // 左边产生的小和+右边产生的小和+合并产生的小和就是整个数组的小和&#10;        return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static int merge(int[] arr, int l, int m, int r) {&#10;        // 辅助数组&#10;        int[] help = new int[r - l + 1];&#10;        // 辅助数组下标&#10;        int i = 0;&#10;        // 左半边数组的指针&#10;        int p1 = l;&#10;        // 右半边数组的指针&#10;        int p2 = m + 1;&#10;        // 小和&#10;        int res = 0;&#10;        // 指针没有越界&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r) {&#10;            // 如果左边指向的值小于右边指向的值，那么p1位置的值一定小于p2以后的所有值，因为是有序的，这时候产生小和&#10;            res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        // p1没有越界，说明p2越界了，将左边剩余元素拷贝到辅助数组&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;        // p2没有越界，说明p1越界了&#10;        while (p2 &lt;= r) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;        // 将辅助数组元素拷贝会原数组&#10;        for (i = 0; i &lt; help.length; i++) {&#10;            arr[l + i] = help[i];&#10;        }&#10;        return res;&#10;    }&#10;}" description="数组 - 归并衍生的小和问题 - OYArrayMergeMinSum" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarrayDutchFlag" value="public class Solution {&#10;    public static int[] partition(int[] arr, int l, int r, int p) {&#10;        //less,more 分别是少于和大于的区域指针&#10;        int less = l - 1;&#10;        int more = r + 1;&#10;        int cur = l;&#10;        while (cur &lt; more) {&#10;            //当前位置的数如果少于P就和少于区域的下一个交换&#10;            //如果大于P就和大于区域的前一个交换&#10;            //如果等于就直接跳到下一个&#10;            if (arr[cur] &lt; p) {&#10;                swap(arr, ++less, l++);&#10;            } else if (arr[cur] &gt; p) {&#10;                //因为刚交换过来的数还不知道大小，所以应该先判断，而需要指向下一个&#10;                swap(arr, --more, cur);&#10;            } else {&#10;                cur++;&#10;            }&#10;        }&#10;        return new int[] { less + 1, more - 1 };&#10;    }&#10;&#10;    // for test&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 荷兰国旗问题 - OYArrayDutchFlag" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarrayfibonacci" value="//非递归算法&#10;public static long Fib(long num){&#10;    long first = 0;&#10;    long second = 1;&#10;    long third = 0;&#10;    for (int i = 2; i &lt;= num; i++){&#10;        third = first + second;&#10;        first = second;&#10;        second = third;&#10;    }&#10;    return third;&#10;}&#10;&#10;//递归算法&#10;public static long Fib(long num){&#10;    if ((num == 1) || num == 0){&#10;        return num;&#10;    }&#10;    return Fib(num - 1) + Fib(num - 2);&#10;}&#10;// 递归缺点：可能导致栈溢出，时间复杂度太高为大O2的n次方。" description="数组 - 斐波那契数列 - OYArrayFibonacci" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraybinarysearch" value="public class Solution {&#10;    public static int commonBinarySearch(int[] arr,int target) {&#10;        int low = 0;&#10;        int high = arr.length - 1;&#10;        int middle = 0;&#10;&#10;        if (low &gt; high || target &lt; arr[low] || target &gt; arr[high]) {&#10;            return -1;&#10;        }&#10;        while (low &lt;= high){&#10;            middle = (high + low)/2;&#10;            if (arr[middle] &lt; target){&#10;                low = middle + 1;&#10;            }else if (arr[middle] &gt; target){&#10;                high = middle - 1;&#10;            }else {&#10;                return middle;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;}" description="数组 - 二分查找 - OYArrayBinarySearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortbucket" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    // only for 0~200 value&#10;    public static void bucketSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        int max = Integer.MIN_VALUE;&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            max = Math.max(max, arr[i]);&#10;        }&#10;        int[] bucket = new int[max + 1];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            bucket[arr[i]]++;&#10;        }&#10;        int i = 0;&#10;        for (int j = 0; j &lt; bucket.length; j++) {&#10;            while (bucket[j]-- &gt; 0) {&#10;                arr[i++] = j;&#10;            }&#10;        }&#10;    }&#10;&#10;    // for test&#10;    public static void comparator(int[] arr) {&#10;        Arrays.sort(arr);&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static boolean isEqual(int[] arr1, int[] arr2) {&#10;        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {&#10;            return false;&#10;        }&#10;        if (arr1 == null &amp;&amp; arr2 == null) {&#10;            return true;&#10;        }&#10;        if (arr1.length != arr2.length) {&#10;            return false;&#10;        }&#10;        for (int i = 0; i &lt; arr1.length; i++) {&#10;            if (arr1[i] != arr2[i]) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    // for test&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 150;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            bucketSort(arr1);&#10;            comparator(arr2);&#10;            if (!isEqual(arr1, arr2)) {&#10;                succeed = false;&#10;                printArray(arr1);&#10;                printArray(arr2);&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;&#10;        int[] arr = generateRandomArray(maxSize, maxValue);&#10;        printArray(arr);&#10;        bucketSort(arr);&#10;        printArray(arr);&#10;    }&#10;&#10;}" description="数组 - 桶排序 - OYArraySortBucket" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraybucketdifference" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    public static int maxGap(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        int len = nums.length;&#10;        int min = Integer.MAX_VALUE;&#10;        int max = Integer.MIN_VALUE;&#10;        // 获取数组中最大和最小的数字&#10;        for (int i = 0; i &lt; len; i++) {&#10;            min = Math.min(min, nums[i]);&#10;            max = Math.max(max, nums[i]);&#10;        }&#10;        if (min == max) {&#10;            return 0;&#10;        }&#10;        // 开始建立桶,每个桶需要存放的信息是这个桶的最大值最小值已经是否有存放数字&#10;        boolean[] hasNum = new boolean[len + 1];&#10;        int[] maxs = new int[len + 1];&#10;        int[] mins = new int[len + 1];&#10;        int bid = 0;&#10;        // 开始遍历保证当前桶的最小值距离左边有存放数字的桶的最大值的差值，记录下来&#10;        for (int i = 0; i &lt; len; i++) {&#10;            bid = bucket(nums[i], len, min, max);&#10;            mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];&#10;            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];&#10;            hasNum[bid] = true;&#10;        }&#10;        int res = 0;&#10;        int lastMax = maxs[0];&#10;        int i = 1;&#10;        for (; i &lt;= len; i++) {&#10;            if (hasNum[i]) {&#10;                res = Math.max(res, mins[i] - lastMax);&#10;                lastMax = maxs[i];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;    // 定位一个数是属于几号桶&#10;    public static int bucket(long num, long len, long min, long max) {&#10;        return (int) ((num - min) * len / (max - min));&#10;    }&#10;&#10;    // for test&#10;    public static int comparator(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        Arrays.sort(nums);&#10;        int gap = Integer.MIN_VALUE;&#10;        for (int i = 1; i &lt; nums.length; i++) {&#10;            gap = Math.max(nums[i] - nums[i - 1], gap);&#10;        }&#10;        return gap;&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 100;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            if (maxGap(arr1) != comparator(arr2)) {&#10;                succeed = false;&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;    }&#10;&#10;}&#10;" description="数组 - 桶排序衍生的相邻数最大差 - OYArrayBucketMaxDifference" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>