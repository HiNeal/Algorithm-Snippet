<templateSet group="Algorithm">
  <template name="oytreepreorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    // 节点的基本构造&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 递归前序遍历&#10;    public static void preOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        System.out.print(head.value + &quot; &quot;);&#10;        preOrderRecur(head.left);&#10;        preOrderRecur(head.right);&#10;    }&#10;&#10;    // 非递归前序遍历&#10;    public static void preOrderUnRecur(Node head) {&#10;        System.out.print(&quot;pre-order: &quot;);&#10;        if (head != null) {&#10;            // 采用栈结构&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            stack.add(head);&#10;            while (!stack.isEmpty()) {&#10;                // 这里的head是复用的，表示当前节点&#10;                head = stack.pop();&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 整体的顺序是先压右后压左&#10;                if (head.right != null) {&#10;                    stack.push(head.right);&#10;                }&#10;                if (head.left != null) {&#10;                    stack.push(head.left);&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 前序遍历 - OYTreePreOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeinorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    //递归&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        System.out.print(head.value + &quot; &quot;);&#10;        inOrderRecur(head.right);&#10;    }&#10;&#10;    //非递归&#10;    public static void inOrderUnRecur(Node head) {&#10;        System.out.print(&quot;in-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();//左根右&#10;            //！stack.isEmpty这个条件只是用来判断是否结束而已，关键的是head != null这个条件&#10;            while (!stack.isEmpty() || head != null) {&#10;                //如果当前节点不为空将当前节点压入栈然后当前节点往左;当前节点为空从栈拿一个打印，然后当前节点往右边跑&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                } else {&#10;                    //把当前节点指向了从栈弹出的那个节点&#10;                    head = stack.pop();&#10;                    System.out.print(head.value + &quot; &quot;);&#10;                    head = head.right;&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 中序遍历 - OYTreeInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeposorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        inOrderRecur(head.right);&#10;        System.out.print(head.value + &quot; &quot;);&#10;    }&#10;&#10;    public static void posOrderUnRecur1(Node head) {&#10;        System.out.print(&quot;pos-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();&#10;            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();&#10;            s1.push(head);&#10;            while (!s1.isEmpty()) {&#10;                head = s1.pop();&#10;                s2.push(head);&#10;                //本来是打印的时机，但你先不打印全部先放到辅助栈s2&#10;                if (head.left != null) {&#10;                    s1.push(head.left);&#10;                }&#10;                if (head.right != null) {&#10;                    s1.push(head.right);&#10;                }&#10;            }&#10;            //再打印栈s2&#10;            while (!s2.isEmpty()) {&#10;                System.out.print(s2.pop().value + &quot; &quot;);&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 后序遍历 -OYTreePosOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreelevelorder" value="public class Solution {&#10;    public static class Node {&#10;        int  value;&#10;        Node left;&#10;        Node right;&#10;&#10;        public Node(int data){&#10;            this.value = data;&#10;        }&#10;    }&#10;    &#10;    public static void levelRead(Node head) {&#10;        // 当结点非空时才进行操作&#10;        if (head != null) {&#10;            // 用于存放还未遍历的元素&#10;            LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();&#10;            // 将根结点入队&#10;            queue.add(head);&#10;            // 用于记录当前处理的结点&#10;            //Node head;&#10;&#10;            // 队列非空则进行处理&#10;            while (!queue.isEmpty()) {&#10;                // remove()表示删除队首元素&#10;                head = queue.remove();&#10;                // 输出队首元素的值&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 如果左子结点不为空，则左子结点入队&#10;                if (head.left != null) {&#10;                    queue.add(head.left);&#10;                }&#10;                // 如果右子结点不为空，则左子结点入队&#10;                if (head.right != null) {&#10;                    queue.add(head.right);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" description="二叉树 -  层序遍历 -OYTreeLevelOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgebalance" value="/*&#10; * 判断一颗二叉树是否是平衡二叉树，它是一棵空树或任意节点左右两个子树的高度差的绝对值不超过1称为平衡二叉树&#10; *&#10; * 这道题目充分体现了递归对于解决树相关算法题的作用,如果我们抛开先序中序后序的打印时机,其实递归来到每个节点的次数是三次&#10; * 我既然可以回到要给节点三次,我们就可以收集左子树和右子树的信息,最后回到根节点,进行判断,可以总结为一个高度解题套路&#10; * 譬如我为了判断X为根节点的树是不是平衡树,我们可以先判断节点X的左树是否平衡,右树是否平衡,然后获取左树高度和右树高度比较是否超过1&#10; * 套路就是要设计我们的递归返回结构,对于这道题来说我们需要递归函数给我们返回信息包括了这棵树是否平衡和这棵树高度;&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 设计递归的返回结构&#10;    public static class ReturnData{&#10;        // 是否是平衡二叉树&#10;        public boolean isBalance;&#10;        // 树的高度&#10;        public int height;&#10;&#10;        public ReturnData(boolean isBalance,int height){&#10;            this.isBalance = isBalance;&#10;            this.height = height;&#10;        }&#10;    }&#10;&#10;    public static boolean isBalanceTree(Node head) {&#10;        return process(head).isBalance;&#10;    }&#10;&#10;    // 设计递归函数,返回信息包括该树是否是平衡二叉树以及该树的高度&#10;    public static ReturnData process(Node head){&#10;        // 如果是空树认为也算是平衡二叉树&#10;        if(head == null){&#10;            return new ReturnData(true,0);&#10;        }&#10;        ReturnData leftData = process(head.left);&#10;        // 如果左树已经是不平衡直接返回不平衡&#10;        if(!leftData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        ReturnData rightData = process(head.right);&#10;        // 如果右树已经是不平衡直接返回不平衡&#10;        if(!rightData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // 说明左树和右树都已经平衡了&#10;        if(Math.abs(leftData.height - rightData.height) &gt; 1){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // return在递归中很重要,左树和右树高度较大的那个加1就是我自己的高度&#10;        return new ReturnData(true,Math.max(leftData.height , rightData.height) + 1);&#10;    }&#10;&#10;}&#10;" description="二叉树 - 判断平衡二叉树 - OYTreeJudgeBalance" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreefindbehindnode" value="import java.util.*;&#10;&#10;/* 解题规律:&#10; * 1.首先我们要明白后继节点值得是,在二叉树终须遍历序列中,node的下一个节点叫做node的后继节点&#10; * 2.如果节点X有右子树,那么该节点的后继节点一定是其右子树最左的节点(结合中序遍历思考得出);&#10; * 3.如果节点X没有右子树，通过节点X的Parent指针找节点X的父节点,一直往上找，直到节点X是该某个节点的左孩子，那么这个某个节点就是X节点的后继节点&#10; */&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;        public Node parent;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static Node getSuccessorNode(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;&#10;        if (node.right != null) {&#10;            //如果一个节点有右子树,直接找到这颗右子树上最左的节点&#10;            return getLeftMost(node.right);&#10;        } else {&#10;            Node parent = node.parent;&#10;            //parent != null处理边界值，parent.left != node当前节点等于自己的左孩子停&#10;            while (parent != null &amp;&amp; parent.left != node) {&#10;                node = parent;&#10;                parent = node.parent;&#10;            }&#10;            return parent;&#10;        }&#10;    }&#10;&#10;    //拿到右子树上最左的节点&#10;    public static Node getLeftMost(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;        while (node.left != null) {&#10;            node = node.left;&#10;        }&#10;        return node;&#10;    }&#10;}" description="二叉树 - 查找后继节点 - OYTreeFindBehindNode" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgesearch" value="import java.util.*;&#10;&#10;/*&#10; * 判断一棵树是否是搜索二叉树，左子树值比自己小，右子树值比自己大。其实只要满足二叉树中序遍历结果是依次升序的就是搜索二叉树&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean inOrderUnRecur(Node head) {&#10;        if (head != null) {&#10;            int pre = 0;&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            while(!stack.isEmpty() || head != null) {&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                }else {&#10;                    stack.pop();&#10;                    // 当前这个数是否比前一个数小则不满足搜索二叉树&#10;                    if (head.value &lt; pre){&#10;                        return false;&#10;                    }&#10;                    head = head.right;&#10;                }&#10;            }&#10;            return true;&#10;        }&#10;    }&#10;}" description="二叉树 - 判断搜索二叉树 - OYTreeJudgeSearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgecomplete" value="import java.util.*;&#10;&#10;/* 如何判断一个数是否是完全二叉树,按层一个节点一个节点遍历,每个节点需要满足下面两个条件&#10; * 第一阶段：如果一个节点只有右孩子没有左孩子绝对不是完全二叉树,可以直接返回false&#10; * 第二阶段：如果一个节点不是左右两个孩子都全(那么这里要么是有左孩子没有右孩子要么是左右都没有孩子)，&#10; *         那么在这样的情况下按层遍历如果未遍历的节点都是叶子节点则说明是完全二叉树&#10; */&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean isCompleteBinaryTree(Node head) {&#10;        if (head == null) {&#10;            return true;&#10;        }&#10;        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();&#10;        //标志是否进入了第二阶段，开启后续节点都是叶节点的这样一个阶段&#10;        boolean leaf = false;&#10;        Node l = null;&#10;        Node r = null;&#10;        queue.offer(head);&#10;        while (!queue.isEmpty()) {&#10;            head = queue.poll();&#10;            l = head.left;&#10;            r = head.right;&#10;            //这个if语句中有两个判断条件：&#10;            //第一个条件：如果我开启了第二阶段了 并且左孩子不为空或者右孩子不为空 (标准二)&#10;            //第二个条件：左孩子为空，右孩子也不为空(标准一)&#10;            if ((leaf &amp;&amp; (l != null || r != null))&#10;                    ||&#10;                    (l == null &amp;&amp; r != null)){&#10;                return false;&#10;            }&#10;            if (l != null) {&#10;                queue.offer(l);&#10;            }&#10;            if (r != null) {&#10;                queue.offer(r);&#10;            }&#10;            if (l == null || r == null) {&#10;                //进入第二阶段&#10;                leaf = true;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="二叉树 - 判断完全二叉树 - OYTreeJudgeComplete" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortbubble" value="public class Solution {&#10;    public static void bubbleSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;&#10;        for (int end = arr.length -1; end &gt; 0; end--){&#10;            //设置这一趟并未发生交换&#10;            boolean exchange = false;&#10;            for (int i = 0; i &lt; end; i++){&#10;                if (arr[i] &gt; arr[i+1]){&#10;                    swap(arr, i, i + 1);&#10;                    //已经发生交换&#10;                    exchange = true;&#10;                }&#10;            }&#10;            //如果没有发生交换则break说明前面都已经排序完毕，节省没必要的比较&#10;            if (!exchange) break;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 冒泡排序 - OYArraySortBubble" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortselection" value="public class Solution {&#10;    public static void selectionSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        //i &lt; length - 1数组的最后一位没有必要再进行比较&#10;        for (int i = 0; i &lt; arr.length - 1; i++){&#10;            //我定义的最小值的Index&#10;            int minIndex = i;&#10;            //这里就可以说j对于i是不变的，虽然i是变的；j其实是每一趟的起始值&#10;            for (int j = i + 1;j &lt; arr.length;j++){&#10;                //实际找到的minIndex&#10;                minIndex = arr[j] &lt; arr[minIndex] ? j:minIndex;&#10;            }&#10;            swap(arr, i, minIndex);&#10;        }&#10;    }&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;    //打印数组的每一个元素出来&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);//这里加空格&#10;        }&#10;        //下面这句总体换一行，细节真的很关键&#10;        System.out.println();&#10;    }&#10;}" description="数组 - 选择排序 - OYArraySortSelection" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortinsert" value="public class Solution {&#10;    public static void insertSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        for (int i = 1; i &lt; arr.length; i++) {&#10;            //就像打扑克牌排序一样插入排序，一张牌来了，从右往左遍历&#10;            for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {&#10;                swap(arr, j, j + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 插入排序 - OYArraySortInsert" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortmerge" value="public class Solution {&#10;    public static void mergeSort(int[] arr){&#10;        if (arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int l,int r){&#10;        if(l == r){&#10;            return;&#10;        }&#10;        int mid = l + ((r - l) &gt;&gt; 1);&#10;        mergeSort(arr, l, mid);&#10;        mergeSort(arr, mid+1, r);&#10;        merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static void merge(int[] arr, int l, int m, int r){&#10;        int[] help = new int[r - l + 1];&#10;        int i = 0;&#10;        int p1 = l;&#10;        int p2 = m + 1;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r){&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        while (p1 &lt;= m){&#10;            help[i++] = arr[p1++];&#10;        }&#10;        while (p2 &lt;= r){&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++){&#10;            arr[l + i] = help[i];&#10;        }&#10;    }&#10;}&#10;" description="数组 - 归并排序 - OYArraySortMerge" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortquick" value="public class Solution {&#10;    public static void quickSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        quickSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void quickSort(int[] arr, int L, int R) {&#10;        //这个条件很重要,整个过程必须要在L&lt;R下进行&#10;        if (L &lt; R) {&#10;            //随机选择一个数和最后一个数交换，然后采用最后一位数做标志位&#10;            swap(arr, L + (int) (Math.random() * (R - L + 1)), R);&#10;            int[] p = partition(arr, L, R);&#10;            //递归遍历,每次确定中间的一片数字&#10;            quickSort(arr, L, p[0] - 1);&#10;            quickSort(arr, p[1] + 1, R);&#10;        }&#10;    }&#10;&#10;    public static int[] partition(int[] arr, int L, int R) {&#10;        //数组第零位的前面一位,这里复用了L变量而已&#10;        int less = L - 1;&#10;        //把数组的最后一位当成了Partition问题中的比较数字&#10;        int more = R;&#10;&#10;        while (L &lt; more) {&#10;            if (arr[L] &lt; arr[R]) {&#10;                swap(arr, ++less, L++);&#10;            } else if (arr[L] &gt; arr[R]) {&#10;                swap(arr, --more, L);&#10;            } else {&#10;                L++;&#10;            }&#10;        }&#10;        //因为最后一位并没有参与遍历此时数组的划分为 &lt;X | =X | &gt;X | X 四个区域&#10;        //为此我们要通过swap函数交换为 &lt;X | =X | &gt;X 三个区域&#10;        swap(arr, more, R);&#10;        //返回等于区域相应的下标&#10;        return new int[] { less + 1, more };&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}&#10;" description="数组 - 快速排序 - OYArraySortQuick" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortHeap" value="import java.util.Arrays;&#10;&#10;&#10;public class Solution {&#10;&#10;    public static void heapSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        // 下面这一步后整个数组就是大根堆结构了&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            // 依次把i位置上的数加进来，让他从0-i位置上称为大根堆&#10;            heapInsert(arr, i);&#10;        }&#10;        int heapSize = arr.length;&#10;&#10;        // 将堆顶与堆底最后一个数字交换&#10;        swap(arr, 0, --heapSize);&#10;&#10;        while (heapSize &gt; 0) {&#10;            // 每次都修正整个堆，让堆顶是最大的数字&#10;            heapify(arr, 0, heapSize);&#10;            // 将堆顶与heapSize最后一个数交换,每次交换都缩小heapSize的范围，将已经排序完毕的数字排出去&#10;            swap(arr, 0, --heapSize);&#10;        }&#10;    }&#10;&#10;    //建立大根堆,把数组变为大根堆结构,index表示即将要加进来的节点&#10;    public static void heapInsert(int[] arr, int index) {&#10;        // while循环将子节点比父节点大的节点提上来&#10;        while (arr[index] &gt; arr[(index - 1) / 2]) {&#10;            // 当前我比我的父位置要大，则交换&#10;            swap(arr, index, (index - 1) / 2);&#10;            // 交换完之后继续与父位置进行比较直到满足大根堆&#10;            // 此处精妙之处在于当节点一直跳到最顶的节点那么会变成arr[0]与arr[(0-1)/2]比较，则必定相等跳出循环&#10;            index = (index - 1) / 2;&#10;        }&#10;    }&#10;&#10;    // 修正数组为堆结构,这个函数的意思是在0 ~ heapSize-1我认为形成了堆，除了这个范围我认为越界；&#10;    // index的值发生了变小了，导致index这个节点应该往下沉&#10;    // heapSize的意思是整个堆上有多少个数，与数组个数并没有关系，但一定不会比数组个数大；&#10;    public static void heapify(int[] arr, int index, int heapSize) {&#10;        int left = index * 2 + 1;&#10;        //while成立条件是我的左还是还在堆上&#10;        while (left &lt; heapSize) {&#10;            //找出左右节点最大值的下标，left + 1表示右孩子;只有你有右孩子并且右孩子比左孩子要大那么largest才是右孩子&#10;            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left]&#10;                    ? left + 1&#10;                    : left;&#10;            //找到左右节点最大值与父节点比较找到最大值下标，并将其作为largest&#10;            largest = arr[largest] &gt; arr[index] ? largest : index;&#10;            //如果发现最大值是自己则不需要交换break&#10;            if (largest == index) {&#10;                break;&#10;            }&#10;            //largest != index&#10;            swap(arr, largest, index);&#10;            index = largest;&#10;            //left又往下走重复整个while循环&#10;            left = index * 2 + 1;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 堆排序 - OYArraySortHeap" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraynixudui" value="public class Solution {&#10;    public static void niXuDui(int[] arr) {&#10;        if(arr == null || arr.length &lt; 2)&#10;            return;&#10;&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int L, int R) {&#10;        if(L == R) {&#10;            return;&#10;        }&#10;&#10;        int mid = L + (R - L) / 2;&#10;        mergeSort(arr, L, mid);&#10;        mergeSort(arr, mid + 1, R);&#10;        merge(arr, L, mid, R);&#10;    }&#10;&#10;    public static void merge(int[] arr, int L, int m, int R) {&#10;        int[] help = new int[R - L + 1];&#10;        int i = 0;&#10;        int p1 = L;&#10;        int p2 = m + 1;&#10;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= R) {&#10;            // 如果这个条件成立，那么左半部分的所有数一定大于右半部分&#10;            if(arr[p1] &gt; arr[p2]) {&#10;                for(int j = p1; j &lt;= m; j++) {&#10;                    System.out.println(arr[j] + &quot;, &quot; + arr[p2]);&#10;                }&#10;            }&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;&#10;        while (p2 &lt;= R) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++) {&#10;            arr[L + i] = help[i];&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] a = {1, 3, 4, 2, 5};&#10;        niXuDui(a);&#10;&#10;    }&#10;}" description="数组 - 归并衍生的逆序对 - OYArrayMergenixudui" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraymergeminsum" value="public class Solution {&#10;    public static int smallSum(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        return mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static int mergeSort(int[] arr, int l, int r) {&#10;        if (l == r) {&#10;            return 0;&#10;        }&#10;        int mid = l + (r - l) &gt;&gt; 1;&#10;        // 左边产生的小和+右边产生的小和+合并产生的小和就是整个数组的小和&#10;        return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static int merge(int[] arr, int l, int m, int r) {&#10;        // 辅助数组&#10;        int[] help = new int[r - l + 1];&#10;        // 辅助数组下标&#10;        int i = 0;&#10;        // 左半边数组的指针&#10;        int p1 = l;&#10;        // 右半边数组的指针&#10;        int p2 = m + 1;&#10;        // 小和&#10;        int res = 0;&#10;        // 指针没有越界&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r) {&#10;            // 如果左边指向的值小于右边指向的值，那么p1位置的值一定小于p2以后的所有值，因为是有序的，这时候产生小和&#10;            res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        // p1没有越界，说明p2越界了，将左边剩余元素拷贝到辅助数组&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;        // p2没有越界，说明p1越界了&#10;        while (p2 &lt;= r) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;        // 将辅助数组元素拷贝会原数组&#10;        for (i = 0; i &lt; help.length; i++) {&#10;            arr[l + i] = help[i];&#10;        }&#10;        return res;&#10;    }&#10;}" description="数组 - 归并衍生的小和问题 - OYArrayMergeMinSum" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarrayDutchFlag" value="public class Solution {&#10;    public static int[] partition(int[] arr, int l, int r, int p) {&#10;        //less,more 分别是少于和大于的区域指针&#10;        int less = l - 1;&#10;        int more = r + 1;&#10;        int cur = l;&#10;        while (cur &lt; more) {&#10;            //当前位置的数如果少于P就和少于区域的下一个交换&#10;            //如果大于P就和大于区域的前一个交换&#10;            //如果等于就直接跳到下一个&#10;            if (arr[cur] &lt; p) {&#10;                swap(arr, ++less, l++);&#10;            } else if (arr[cur] &gt; p) {&#10;                //因为刚交换过来的数还不知道大小，所以应该先判断，而需要指向下一个&#10;                swap(arr, --more, cur);&#10;            } else {&#10;                cur++;&#10;            }&#10;        }&#10;        return new int[] { less + 1, more - 1 };&#10;    }&#10;&#10;    // for test&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 荷兰国旗问题 - OYArrayDutchFlag" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarrayfibonacci" value="//非递归算法&#10;public static long Fib(long num){&#10;    long first = 0;&#10;    long second = 1;&#10;    long third = 0;&#10;    for (int i = 2; i &lt;= num; i++){&#10;        third = first + second;&#10;        first = second;&#10;        second = third;&#10;    }&#10;    return third;&#10;}&#10;&#10;//递归算法&#10;public static long Fib(long num){&#10;    if ((num == 1) || num == 0){&#10;        return num;&#10;    }&#10;    return Fib(num - 1) + Fib(num - 2);&#10;}&#10;// 递归缺点：可能导致栈溢出，时间复杂度太高为大O2的n次方。" description="数组 - 斐波那契数列 - OYArrayFibonacci" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraybinarysearch" value="public class Solution {&#10;    public static int commonBinarySearch(int[] arr,int target) {&#10;        int low = 0;&#10;        int high = arr.length - 1;&#10;        int middle = 0;&#10;&#10;        if (low &gt; high || target &lt; arr[low] || target &gt; arr[high]) {&#10;            return -1;&#10;        }&#10;        while (low &lt;= high){&#10;            middle = (high + low)/2;&#10;            if (arr[middle] &lt; target){&#10;                low = middle + 1;&#10;            }else if (arr[middle] &gt; target){&#10;                high = middle - 1;&#10;            }else {&#10;                return middle;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;}" description="数组 - 二分查找 - OYArrayBinarySearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraysortbucket" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    // only for 0~200 value&#10;    public static void bucketSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        int max = Integer.MIN_VALUE;&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            max = Math.max(max, arr[i]);&#10;        }&#10;        int[] bucket = new int[max + 1];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            bucket[arr[i]]++;&#10;        }&#10;        int i = 0;&#10;        for (int j = 0; j &lt; bucket.length; j++) {&#10;            while (bucket[j]-- &gt; 0) {&#10;                arr[i++] = j;&#10;            }&#10;        }&#10;    }&#10;&#10;    // for test&#10;    public static void comparator(int[] arr) {&#10;        Arrays.sort(arr);&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static boolean isEqual(int[] arr1, int[] arr2) {&#10;        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {&#10;            return false;&#10;        }&#10;        if (arr1 == null &amp;&amp; arr2 == null) {&#10;            return true;&#10;        }&#10;        if (arr1.length != arr2.length) {&#10;            return false;&#10;        }&#10;        for (int i = 0; i &lt; arr1.length; i++) {&#10;            if (arr1[i] != arr2[i]) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    // for test&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 150;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            bucketSort(arr1);&#10;            comparator(arr2);&#10;            if (!isEqual(arr1, arr2)) {&#10;                succeed = false;&#10;                printArray(arr1);&#10;                printArray(arr2);&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;&#10;        int[] arr = generateRandomArray(maxSize, maxValue);&#10;        printArray(arr);&#10;        bucketSort(arr);&#10;        printArray(arr);&#10;    }&#10;&#10;}" description="数组 - 桶排序 - OYArraySortBucket" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraybucketdifference" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    public static int maxGap(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        int len = nums.length;&#10;        int min = Integer.MAX_VALUE;&#10;        int max = Integer.MIN_VALUE;&#10;        // 获取数组中最大和最小的数字&#10;        for (int i = 0; i &lt; len; i++) {&#10;            min = Math.min(min, nums[i]);&#10;            max = Math.max(max, nums[i]);&#10;        }&#10;        if (min == max) {&#10;            return 0;&#10;        }&#10;        // 开始建立桶,每个桶需要存放的信息是这个桶的最大值最小值已经是否有存放数字&#10;        boolean[] hasNum = new boolean[len + 1];&#10;        int[] maxs = new int[len + 1];&#10;        int[] mins = new int[len + 1];&#10;        int bid = 0;&#10;        // 开始遍历保证当前桶的最小值距离左边有存放数字的桶的最大值的差值，记录下来&#10;        for (int i = 0; i &lt; len; i++) {&#10;            bid = bucket(nums[i], len, min, max);&#10;            mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];&#10;            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];&#10;            hasNum[bid] = true;&#10;        }&#10;        int res = 0;&#10;        int lastMax = maxs[0];&#10;        int i = 1;&#10;        for (; i &lt;= len; i++) {&#10;            if (hasNum[i]) {&#10;                res = Math.max(res, mins[i] - lastMax);&#10;                lastMax = maxs[i];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;    // 定位一个数是属于几号桶&#10;    public static int bucket(long num, long len, long min, long max) {&#10;        return (int) ((num - min) * len / (max - min));&#10;    }&#10;&#10;    // for test&#10;    public static int comparator(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        Arrays.sort(nums);&#10;        int gap = Integer.MIN_VALUE;&#10;        for (int i = 1; i &lt; nums.length; i++) {&#10;            gap = Math.max(nums[i] - nums[i - 1], gap);&#10;        }&#10;        return gap;&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 100;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            if (maxGap(arr1) != comparator(arr2)) {&#10;                succeed = false;&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;    }&#10;&#10;}&#10;" description="数组 - 桶排序衍生的相邻数最大差 - OYArrayBucketMaxDifference" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraymergeorder" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;    /*&#10;     * arr1表示数组1   m表示arr1的长度&#10;     * arr2表示数组2   n表示arr2的长度&#10;     * */&#10;    public static void merge(int[] arr1, int m, int[] arr2, int n) {&#10;        //新数组下标以及新数组&#10;        int arrIndex = 0;&#10;        int[] arr = new int[m+n];&#10;&#10;        //双指针&#10;        int i = 0;&#10;        int j = 0;&#10;        while (i &lt; m &amp;&amp; j &lt; n ){&#10;            if (arr1[i] &lt;= arr2[j])&#10;                arr[arrIndex++] = arr1[i++];&#10;            else&#10;                arr[arrIndex++] = arr2[j++];&#10;        }&#10;&#10;        if (i &lt; m)&#10;            while (i&lt;m)&#10;                arr[arrIndex++] = arr1[i++];&#10;&#10;        if (j &lt; n)&#10;            while (j&lt;n)&#10;                arr[arrIndex++] = arr2[j++];&#10;        //把arr中从0开始的长度为整个数组的所有的数放到arr1中去&#10;        System.arraycopy(arr,0,arr1,0,arr.length);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] num1 = {1,2,3,0,0,0};&#10;        int[] num2 = {2,5,6};&#10;        int m = 3; int n = 3;&#10;        merge(num1,m,num2,n);&#10;        System.out.println(Arrays.toString(num1));&#10;    }&#10;}&#10;" description="数组 - 合并有序数组 - OYArrayMergeOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraytwosum" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;    public static int[] twoSum(int[] arr, int target) {&#10;        HashMap&lt;Integer,Integer&gt;  map = new HashMap&lt;&gt;();&#10;        for (int i = 0; i &lt; arr.length;i++){&#10;            //找到该数字的组合数&#10;            int complement = target - arr[i];&#10;            //在map中寻找是否有这个key了,有直接返回&#10;            if (map.containsKey(complement)){&#10;                return new int[] { map.get(complement),i };&#10;            }&#10;            //map中不存在老老实实将以数组的值为key,索引i为value;&#10;            map.put(arr[i],i);&#10;        }&#10;        //抛出异常&#10;        throw new IllegalArgumentException(&quot;No two sum Solution&quot;);&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        int[] arr = {5,3,2,9,7};&#10;        int target = 7;&#10;        int[] result = twoSum(arr,target);&#10;        System.out.println(Arrays.toString(result));&#10;    }&#10;}&#10;" description="数组 - 两数之和 - OYArrayTwoSum" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraytwodimensionsearch" value="/*&#10; *  在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&#10; * 请完 成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&#10; * 思路：从右上角或左下角开始找，逐行删除，或者用二分法查找&#10; */&#10;public class Solution {&#10;    public static boolean findNum(int[][] arr,int target){&#10;        //基本条件判断&#10;        if (arr == null || arr.length &lt; 1 || arr[0].length &lt; 1){&#10;            return false;&#10;        }&#10;&#10;        int row = 0;&#10;        int column = arr[0].length - 1;&#10;        //保证行列边界&#10;        while(row &lt; arr.length &amp;&amp; column &gt;= 0){&#10;            if (arr[row][column] &lt; target){&#10;                row++;&#10;            } else if (arr[row][column] &gt; target){&#10;                column-- ;&#10;            } else{&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;}" description="数组 - 二维数组中查找 - OYArrayTwoDimensionSearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraylistimplementbyarray" value="public class Solution {&#10;    public static class ArrayList&lt;E&gt; {&#10;        // 数组当前可容纳容量&#10;        private int size;&#10;        // 维护一个内部数组&#10;        private E[] elements;&#10;        // 数组默认长度&#10;        private static final int DEFAULT_CAPACITY = 10;&#10;        // 异常告警&#10;        private static final int ELEMENT_NOT_FOUND = -1;&#10;&#10;        //构造函数&#10;        public ArrayList(int capaticy) {&#10;            capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;&#10;            elements = (E[]) new Object[capaticy];&#10;        }&#10;        public ArrayList() {&#10;            this(DEFAULT_CAPACITY);&#10;        }&#10;&#10;        // 在index位置插入一个元素&#10;        public void add(int index, E element) {&#10;            rangeCheckForAdd(index);&#10;            ensureCapacity(size + 1);&#10;&#10;            for (int i = size; i &gt; index; i--) {&#10;                elements[i] = elements[i - 1];&#10;            }&#10;            elements[index] = element;&#10;            size++;&#10;        }&#10;&#10;        // 添加元素到尾部&#10;        public void add(E element) {&#10;            add(size, element);&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            E old = elements[index];&#10;            for (int i = index + 1; i &lt; size; i++) {&#10;                elements[i - 1] = elements[i];&#10;            }&#10;            elements[--size] = null;&#10;            return old;&#10;        }&#10;&#10;        // 清除所有元素&#10;        public void clear() {&#10;            for (int i = 0; i &lt; size; i++) {&#10;                elements[i] = null;&#10;            }&#10;            size = 0;&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E element) {&#10;            rangeCheck(index);&#10;            E old = elements[index];&#10;            elements[index] = element;&#10;            return old;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            rangeCheck(index);&#10;            return elements[index];&#10;        }&#10;&#10;        // 是否包含某个元素&#10;        public boolean contains(E element) {&#10;            return indexOf(element) != ELEMENT_NOT_FOUND;&#10;        }&#10;&#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 保证要有capacity的容量&#10;        private void ensureCapacity(int capacity) {&#10;            int oldCapacity = elements.length;&#10;            if (oldCapacity &gt;= capacity) return;&#10;&#10;            // 新容量为旧容量的1.5倍&#10;            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);&#10;            E[] newElements = (E[]) new Object[newCapacity];&#10;            for (int i = 0; i &lt; size; i++) {&#10;                newElements[i] = elements[i];&#10;            }&#10;            elements = newElements;&#10;            System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);&#10;        }&#10;&#10;        // 查看元素的索引&#10;        public int indexOf(E element) {&#10;            if (element == null) {&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (elements[i] == null) return i;&#10;                }&#10;            } else {&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (element.equals(elements[i])) return i;&#10;                }&#10;            }&#10;            return ELEMENT_NOT_FOUND;&#10;        }&#10;&#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 增加元素抛出异常,增加元素的index允许和当前容量一样,因为会增加扩容措施&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(elements[i]);&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        ArrayList&lt;Integer&gt; list = new ArrayList(10);&#10;        list.add(10);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.remove(1);&#10;        System.out.println(list);&#10;    }&#10;}" description="数组 - 采用数组实现ArrayList - OYArrayListImplementByArray" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarrayremovesamenuminorder" value="/*&#10; *给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&#10; * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&#10;示例 1:&#10;给定数组 nums = [1,1,2], &#10;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 &#10;你不需要考虑数组中超出新长度后面的元素。&#10;&#10;示例 2:&#10;给定 nums = [0,0,1,1,1,2,2,3,3,4],&#10;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&#10;你不需要考虑数组中超出新长度后面的元素。&#10; */&#10;&#10;public class Solution {&#10;    public static int removeDuplicates(int[] nums) {&#10;        if (nums.length == 0) return 0;&#10;        int i = 0;&#10;        for (int j = 1; j &lt; nums.length; j++) {&#10;            if (nums[j] != nums[i]) {&#10;                i++;&#10;                nums[i] = nums[j];&#10;            }&#10;        }&#10;        //printArray(nums);&#10;        return i + 1;&#10;    }&#10;&#10;    public static void printArray(int[] nums){&#10;        if(nums == null || nums.length &lt; 1){&#10;            return;&#10;        }&#10;        for (int i = 0;i &lt; nums.length;i++){&#10;            System.out.print(nums[i] + &quot; &quot;);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] nums = {0,0,1,1,1,2,2,3,3,4};&#10;        removeDuplicates(nums);&#10;        //这里输出0 1 2 3 4 2 2 3 3 4&#10;        printArray(nums);&#10;    }&#10;}&#10;" description="数组 - 删除排序数组中的重复项 - OYArrayRemoveSameNumInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkjudgecircle" value="class Solution {&#10;    public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;    }&#10;&#10;&#10;    public boolean hasCycle(Node head) {&#10;        if (head == null || head.next == null) return false;&#10;        Node slow = head;&#10;        Node fast = head.next;&#10;&#10;        while (fast != null || fast.next != null){&#10;            if (slow == fast) return true;&#10;            slow = slow.next;&#10;            fast = fast.next.next;&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" description="链表 - 判断链表是否有环 - OYLinkJudgeCircle" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkedlistimplementbyonewaylink" value="&#10;// 用单向链表实现LinkedList&#10;public class Solution {&#10;    public static class SingleLinkedList&lt;E&gt; {&#10;        // 内部元素的个数&#10;        private int size;&#10;        // 指向第一个节点&#10;        private Node&lt;E&gt; first;&#10;        // 异常告警&#10;        private static final int VALUE_NOT_FOUND = -1;&#10;&#10;        // 构建Node节点类&#10;        private class Node&lt;E&gt; {&#10;            E value;&#10;            Node&lt;E&gt; next;&#10;            public Node(E value, Node&lt;E&gt; next) {&#10;                this.value = value;&#10;                this.next = next;&#10;            }&#10;        }&#10;        &#10;        // 在index位置插入一个元素&#10;        public void add(int index, E value) {&#10;            rangeCheckForAdd(index);&#10;            if (index == 0) {&#10;                first = new Node&lt;&gt;(value, first);&#10;            } else {&#10;                Node&lt;E&gt; prev = node(index - 1);&#10;                prev.next = new Node&lt;&gt;(value, prev.next);&#10;            }&#10;            size++;&#10;        }&#10;        &#10;        // 添加元素到尾部&#10;        public void add(E value) {&#10;            add(size, value);&#10;        }&#10;        &#10;        // 清除所有元素&#10;        public void clear() {&#10;            size = 0;&#10;            first = null;&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = first;&#10;            if (index == 0) {&#10;                first = first.next;&#10;            } else {&#10;                Node&lt;E&gt; prev = node(index - 1);&#10;                node = prev.next;&#10;                prev.next = node.next;&#10;            }&#10;            size--;&#10;            return node.value;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            return node(index).value;&#10;        }&#10;&#10;        // 获取元素对应的index&#10;        public int indexOf(E value) {&#10;            if (value == null) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (node.value == null) return i;&#10;                    node = node.next;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (value.equals(node.value)) return i;&#10;                    node = node.next;&#10;                }&#10;            }&#10;            return VALUE_NOT_FOUND;&#10;        }&#10;&#10;        // 获取index位置对应的节点对象&#10;        private Node&lt;E&gt; node(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; index; i++) {&#10;                node = node.next;&#10;            }&#10;            return node;&#10;        }&#10;        &#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E value) {&#10;            Node&lt;E&gt; node = node(index);&#10;            E old = node.value;&#10;            node.value = value;&#10;            return old;&#10;        }&#10;        &#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 做加法抛出异常&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(node.value);&#10;                node = node.next;&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SingleLinkedList list = new SingleLinkedList&lt;&gt;();&#10;        list.add(20);&#10;        list.add(0,10);&#10;        list.add(30);&#10;        System.out.println(list);&#10;    }&#10;}" description="链表 - 用单向链表实现LinkedList - OYLinkedlistImplementByOneWayLink" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkreverse" value="class Solution {&#10;    public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;    }&#10;&#10;    // 递归解法&#10;    public Node reverseList1(Node head) {&#10;        if(head == null || head.next == null) return head;&#10;&#10;        Node newHead = reverseList1(head.next);&#10;        head.next.next = head;&#10;        head.next = null;&#10;        return newHead;&#10;    }&#10;&#10;    // 非递归解法&#10;    public Node reverseList2(Node head) {&#10;        if (head == null || head.next == null) return  head;&#10;&#10;        Node newHead = null;&#10;        while (head != null){&#10;            Node tmpNode = head.next;&#10;            head.next = newHead;&#10;            newHead = head;&#10;            head = tmpNode;&#10;        }&#10;        return newHead;&#10;    }&#10;}" description="链表 - 反转链表 - OYLinkReverse" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkprintcommonpart" value="public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node next;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void printCommonPart(Node head1, Node head2) {&#10;        System.out.print(&quot;Common Part: &quot;);&#10;        while (head1 != null &amp;&amp; head2 != null) {&#10;            if (head1.value &lt; head2.value) {&#10;                head1 = head1.next;&#10;            } else if (head1.value &gt; head2.value) {&#10;                head2 = head2.next;&#10;            } else {&#10;                System.out.print(head1.value + &quot; &quot;);&#10;                head1 = head1.next;&#10;                head2 = head2.next;&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    public static void printLinkedList(Node node) {&#10;        System.out.print(&quot;Linked List: &quot;);&#10;        while (node != null) {&#10;            System.out.print(node.value + &quot; &quot;);&#10;            node = node.next;&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        Node node1 = new Node(2);&#10;        node1.next = new Node(3);&#10;        node1.next.next = new Node(5);&#10;        node1.next.next.next = new Node(6);&#10;&#10;        Node node2 = new Node(1);&#10;        node2.next = new Node(2);&#10;        node2.next.next = new Node(5);&#10;        node2.next.next.next = new Node(7);&#10;        node2.next.next.next.next = new Node(8);&#10;&#10;        printLinkedList(node1);&#10;        printLinkedList(node2);&#10;        printCommonPart(node1, node2);&#10;&#10;    }&#10;}&#10;&#10;" description="链表 - 打印两个有序链表的公共部分 - OYLinkPrintCommonPart" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkdeletenode" value="class Solution {&#10;     public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;     }&#10;&#10;     public void deleteNode(Node node) {&#10;         node.value = node.next.value;&#10;         node.next = node.next.next;&#10;     }&#10; }" description="链表 - 删除链表中的节点 - OYLinkDeleteNode" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkedlistimplementbytwowaylink" value="&#10;&#10;class Solution {&#10;    public class LinkedList&lt;E&gt; {&#10;        // 内部元素的个数&#10;        private int size;&#10;        // 指向第一个节点&#10;        private Node&lt;E&gt; first;&#10;        // 指向最后一个节点&#10;        private Node&lt;E&gt; last;&#10;        // 异常告警&#10;        private static final int VALUE_NOT_FOUND = -1;&#10;&#10;        // 构建Node节点类&#10;        private class Node&lt;E&gt; {&#10;            E value;&#10;            Node&lt;E&gt; prev;&#10;            Node&lt;E&gt; next;&#10;            public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next) {&#10;                this.prev = prev;&#10;                this.value = value;&#10;                this.next = next;&#10;            }&#10;        }&#10;&#10;        // 添加元素到尾部&#10;        public void add(E value) {&#10;            add(size, value);&#10;        }&#10;&#10;        // 在Index位置插入一个元素&#10;        public void add(int index, E value) {&#10;            rangeCheckForAdd(index);&#10;            if (index == size) {&#10;                // 往最后面添加元素&#10;                Node&lt;E&gt; oldLast = last;&#10;                last = new Node&lt;E&gt;(oldLast, value, null);&#10;                if (oldLast == null) {&#10;                    // 这是链表添加的第一个元素&#10;                    first = last;&#10;                } else {&#10;                    oldLast.next = last;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; next = node(index);&#10;                Node&lt;E&gt; prev = next.prev;&#10;                Node&lt;E&gt; node = new Node&lt;E&gt;(prev, value, next);&#10;                next.prev = node;&#10;&#10;                if (prev == null) {&#10;                    // 如果prev == null说明是index == 0&#10;                    first = node;&#10;                } else {&#10;                    prev.next = node;&#10;                }&#10;            }&#10;&#10;            size++;&#10;        }&#10;&#10;        // 清除所有元素&#10;        public void clear() {&#10;            size = 0;&#10;            first = null;&#10;            last = null;&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = node(index);&#10;            Node&lt;E&gt; prev = node.prev;&#10;            Node&lt;E&gt; next = node.next;&#10;&#10;            if (prev == null) {&#10;                // 如果prev == null说明是index == 0&#10;                first = next;&#10;            } else {&#10;                prev.next = next;&#10;            }&#10;&#10;            if (next == null) {&#10;                // 删除最后一位index == size - 1&#10;                last = prev;&#10;            } else {&#10;                next.prev = prev;&#10;            }&#10;&#10;            size--;&#10;            return node.value;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            return node(index).value;&#10;        }&#10;&#10;        // 获取元素对应的index&#10;        public int indexOf(E value) {&#10;            if (value == null) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (node.value == null) return i;&#10;&#10;                    node = node.next;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (value.equals(node.value)) return i;&#10;&#10;                    node = node.next;&#10;                }&#10;            }&#10;            return VALUE_NOT_FOUND;&#10;        }&#10;&#10;        // 获取index位置对应的节点对象&#10;        private Node&lt;E&gt; node(int index) {&#10;            rangeCheck(index);&#10;&#10;            if (index &lt; (size &gt;&gt; 1)) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; index; i++) {&#10;                    node = node.next;&#10;                }&#10;                return node;&#10;            } else {&#10;                Node&lt;E&gt; node = last;&#10;                for (int i = size - 1; i &gt; index; i--) {&#10;                    node = node.prev;&#10;                }&#10;                return node;&#10;            }&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E value) {&#10;            Node&lt;E&gt; node = node(index);&#10;            E old = node.value;&#10;            node.value = value;&#10;            return old;&#10;        }&#10;&#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 做加法抛出异常&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(node);&#10;                node = node.next;&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;}" description="链表 - 双向链表实现LinkedList - OYLinkedListImplementByTwoWayLink" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkjudgepalindrome" value="import java.util.*;&#10;&#10;class Solution{&#10;    public static class Node {&#10;        public int value;&#10;        public Node next;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // need n extra space&#10;    public static boolean isPalindrome1(Node head) {&#10;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;        Node cur = head;&#10;        while (cur != null) {&#10;            stack.push(cur);&#10;            cur = cur.next;&#10;        }&#10;        while (head != null) {&#10;            if (head.value != stack.pop().value) {&#10;                return false;&#10;            }&#10;            head = head.next;&#10;        }&#10;        return true;&#10;    }&#10;}" description="链表 - 判断一个链表是否为回文结构 - OYLinkJudgePalindrome" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oystackimplementbyarray" value="import java.util.*;&#10;&#10;class Solution {&#10;    public class Stack&lt;E&gt; {&#10;        private List&lt;E&gt; list = new ArrayList&lt;E&gt;();&#10;&#10;        public void push(E element) {&#10;            list.add(element);&#10;        }&#10;&#10;        public E pop() {&#10;            return list.remove(list.size() - 1);&#10;        }&#10;&#10;        public E top() {&#10;            return list.get(list.size() - 1);&#10;        }&#10;&#10;        public void clear() {&#10;            list.clear();&#10;        }&#10;&#10;        public int size() {&#10;            return list.size();&#10;        }&#10;&#10;        public boolean isEmpty() {&#10;            return list.isEmpty();&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="栈 - 用数组结构实现固定的栈 - OYStackImplementByArray" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyqueueimplementbystack" value="import java.util.*;&#10;&#10;class Solution {&#10;    public static class ArrayQueue {&#10;        private Integer[] arr;&#10;        // 用 size 把 first 和 end 追的行为解耦掉&#10;        private Integer size;&#10;        // 表示如果拿出一个数应该拿哪里的数&#10;        private Integer first;&#10;        // 表示如果新加一个数应该填到哪里的数&#10;        private Integer last;&#10;&#10;        public ArrayQueue(int initSize) {&#10;            if (initSize &lt; 0) {&#10;                throw new IllegalArgumentException(&quot;The init size is less than 0&quot;);&#10;            }&#10;            arr = new Integer[initSize];&#10;            size = 0;&#10;            first = 0;&#10;            last = 0;&#10;        }&#10;&#10;        public Integer peek() {&#10;            if (size == 0) {&#10;                return null;&#10;            }&#10;            return arr[first];&#10;        }&#10;&#10;        public void push(int obj) {&#10;            if (size == arr.length) {&#10;                throw new ArrayIndexOutOfBoundsException(&quot;The queue is full&quot;);&#10;            }&#10;            size++;&#10;            arr[last] = obj;&#10;            last = last == arr.length - 1 ? 0 : last + 1;&#10;        }&#10;&#10;        public Integer poll() {&#10;            if (size == 0) {&#10;                throw new ArrayIndexOutOfBoundsException(&quot;The queue is empty&quot;);&#10;            }&#10;            size--;&#10;            int tmp = first;&#10;            first = first == arr.length - 1 ? 0 : first + 1;&#10;            return arr[tmp];&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="队列 - 用数组结构实现固定的队列 - OYQueueImplementByStack" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>