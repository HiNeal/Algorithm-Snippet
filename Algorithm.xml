<templateSet group="Algorithm">
  <template name="oytreepreorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    // 节点的基本构造&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 递归前序遍历&#10;    public static void preOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        System.out.print(head.value + &quot; &quot;);&#10;        preOrderRecur(head.left);&#10;        preOrderRecur(head.right);&#10;    }&#10;&#10;    // 非递归前序遍历&#10;    public static void preOrderUnRecur(Node head) {&#10;        System.out.print(&quot;pre-order: &quot;);&#10;        if (head != null) {&#10;            // 采用栈结构&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            stack.add(head);&#10;            while (!stack.isEmpty()) {&#10;                // 这里的head是复用的，表示当前节点&#10;                head = stack.pop();&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 整体的顺序是先压右后压左&#10;                if (head.right != null) {&#10;                    stack.push(head.right);&#10;                }&#10;                if (head.left != null) {&#10;                    stack.push(head.left);&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="Algorithm - 二叉树 - 前序遍历 - OYTreePreOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeinorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    //递归&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        System.out.print(head.value + &quot; &quot;);&#10;        inOrderRecur(head.right);&#10;    }&#10;&#10;    //非递归&#10;    public static void inOrderUnRecur(Node head) {&#10;        System.out.print(&quot;in-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();//左根右&#10;            //！stack.isEmpty这个条件只是用来判断是否结束而已，关键的是head != null这个条件&#10;            while (!stack.isEmpty() || head != null) {&#10;                //如果当前节点不为空将当前节点压入栈然后当前节点往左;当前节点为空从栈拿一个打印，然后当前节点往右边跑&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                } else {&#10;                    //把当前节点指向了从栈弹出的那个节点&#10;                    head = stack.pop();&#10;                    System.out.print(head.value + &quot; &quot;);&#10;                    head = head.right;&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="Algorithm - 二叉树 - 中序遍历 - OYTreeInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreeposorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        inOrderRecur(head.right);&#10;        System.out.print(head.value + &quot; &quot;);&#10;    }&#10;&#10;    public static void posOrderUnRecur1(Node head) {&#10;        System.out.print(&quot;pos-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();&#10;            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();&#10;            s1.push(head);&#10;            while (!s1.isEmpty()) {&#10;                head = s1.pop();&#10;                s2.push(head);&#10;                //本来是打印的时机，但你先不打印全部先放到辅助栈s2&#10;                if (head.left != null) {&#10;                    s1.push(head.left);&#10;                }&#10;                if (head.right != null) {&#10;                    s1.push(head.right);&#10;                }&#10;            }&#10;            //再打印栈s2&#10;            while (!s2.isEmpty()) {&#10;                System.out.print(s2.pop().value + &quot; &quot;);&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="Algorithm - 二叉树 - OYTreePosOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreelevelorder" value="public class Solution {&#10;    public static class Node {&#10;        int  value;&#10;        Node left;&#10;        Node right;&#10;&#10;        public Node(int data){&#10;            this.value = data;&#10;        }&#10;    }&#10;    &#10;    public static void levelRead(Node head) {&#10;        // 当结点非空时才进行操作&#10;        if (head != null) {&#10;            // 用于存放还未遍历的元素&#10;            LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();&#10;            // 将根结点入队&#10;            queue.add(head);&#10;            // 用于记录当前处理的结点&#10;            //Node head;&#10;&#10;            // 队列非空则进行处理&#10;            while (!queue.isEmpty()) {&#10;                // remove()表示删除队首元素&#10;                head = queue.remove();&#10;                // 输出队首元素的值&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 如果左子结点不为空，则左子结点入队&#10;                if (head.left != null) {&#10;                    queue.add(head.left);&#10;                }&#10;                // 如果右子结点不为空，则左子结点入队&#10;                if (head.right != null) {&#10;                    queue.add(head.right);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" description="Algorithm - 二叉树 - OYTreeLevelOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytreejudgebalancetree" value="/*&#10; * 判断一颗二叉树是否是平衡二叉树，它是一棵空树或任意节点左右两个子树的高度差的绝对值不超过1称为平衡二叉树&#10; *&#10; * 这道题目充分体现了递归对于解决树相关算法题的作用,如果我们抛开先序中序后序的打印时机,其实递归来到每个节点的次数是三次&#10; * 我既然可以回到要给节点三次,我们就可以收集左子树和右子树的信息,最后回到根节点,进行判断,可以总结为一个高度解题套路&#10; * 譬如我为了判断X为根节点的树是不是平衡树,我们可以先判断节点X的左树是否平衡,右树是否平衡,然后获取左树高度和右树高度比较是否超过1&#10; * 套路就是要设计我们的递归返回结构,对于这道题来说我们需要递归函数给我们返回信息包括了这棵树是否平衡和这棵树高度;&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 设计递归的返回结构&#10;    public static class ReturnData{&#10;        // 是否是平衡二叉树&#10;        public boolean isBalance;&#10;        // 树的高度&#10;        public int height;&#10;&#10;        public ReturnData(boolean isBalance,int height){&#10;            this.isBalance = isBalance;&#10;            this.height = height;&#10;        }&#10;    }&#10;&#10;    public static boolean isBalanceTree(Node head) {&#10;        return process(head).isBalance;&#10;    }&#10;&#10;    // 设计递归函数,返回信息包括该树是否是平衡二叉树以及该树的高度&#10;    public static ReturnData process(Node head){&#10;        // 如果是空树认为也算是平衡二叉树&#10;        if(head == null){&#10;            return new ReturnData(true,0);&#10;        }&#10;        ReturnData leftData = process(head.left);&#10;        // 如果左树已经是不平衡直接返回不平衡&#10;        if(!leftData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        ReturnData rightData = process(head.right);&#10;        // 如果右树已经是不平衡直接返回不平衡&#10;        if(!rightData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // 说明左树和右树都已经平衡了&#10;        if(Math.abs(leftData.height - rightData.height) &gt; 1){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // return在递归中很重要,左树和右树高度较大的那个加1就是我自己的高度&#10;        return new ReturnData(true,Math.max(leftData.height , rightData.height) + 1);&#10;    }&#10;&#10;}&#10;" description="Algorithm - 二叉树 - 判断平衡二叉树 - OYTreeJudgeBalanceTree" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>