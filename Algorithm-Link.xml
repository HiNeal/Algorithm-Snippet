<templateSet group="Algorithm-Link">
  <template name="oylinkdeletenode" value="class Solution {&#10;     public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;     }&#10;&#10;     public void deleteNode(Node node) {&#10;         node.value = node.next.value;&#10;         node.next = node.next.next;&#10;     }&#10; }" description="链表 - 删除链表中的节点 - OYLinkDeleteNode" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkedlistimplementbyonewaylink" value="&#10;// 用单向链表实现LinkedList&#10;public class Solution {&#10;    public static class SingleLinkedList&lt;E&gt; {&#10;        // 内部元素的个数&#10;        private int size;&#10;        // 指向第一个节点&#10;        private Node&lt;E&gt; first;&#10;        // 异常告警&#10;        private static final int VALUE_NOT_FOUND = -1;&#10;&#10;        // 构建Node节点类&#10;        private class Node&lt;E&gt; {&#10;            E value;&#10;            Node&lt;E&gt; next;&#10;            public Node(E value, Node&lt;E&gt; next) {&#10;                this.value = value;&#10;                this.next = next;&#10;            }&#10;        }&#10;        &#10;        // 在index位置插入一个元素&#10;        public void add(int index, E value) {&#10;            rangeCheckForAdd(index);&#10;            if (index == 0) {&#10;                first = new Node&lt;&gt;(value, first);&#10;            } else {&#10;                Node&lt;E&gt; prev = node(index - 1);&#10;                prev.next = new Node&lt;&gt;(value, prev.next);&#10;            }&#10;            size++;&#10;        }&#10;        &#10;        // 添加元素到尾部&#10;        public void add(E value) {&#10;            add(size, value);&#10;        }&#10;        &#10;        // 清除所有元素&#10;        public void clear() {&#10;            size = 0;&#10;            first = null;&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = first;&#10;            if (index == 0) {&#10;                first = first.next;&#10;            } else {&#10;                Node&lt;E&gt; prev = node(index - 1);&#10;                node = prev.next;&#10;                prev.next = node.next;&#10;            }&#10;            size--;&#10;            return node.value;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            return node(index).value;&#10;        }&#10;&#10;        // 获取元素对应的index&#10;        public int indexOf(E value) {&#10;            if (value == null) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (node.value == null) return i;&#10;                    node = node.next;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (value.equals(node.value)) return i;&#10;                    node = node.next;&#10;                }&#10;            }&#10;            return VALUE_NOT_FOUND;&#10;        }&#10;&#10;        // 获取index位置对应的节点对象&#10;        private Node&lt;E&gt; node(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; index; i++) {&#10;                node = node.next;&#10;            }&#10;            return node;&#10;        }&#10;        &#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E value) {&#10;            Node&lt;E&gt; node = node(index);&#10;            E old = node.value;&#10;            node.value = value;&#10;            return old;&#10;        }&#10;        &#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 做加法抛出异常&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(node.value);&#10;                node = node.next;&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SingleLinkedList list = new SingleLinkedList&lt;&gt;();&#10;        list.add(20);&#10;        list.add(0,10);&#10;        list.add(30);&#10;        System.out.println(list);&#10;    }&#10;}" description="链表 - 用单向链表实现LinkedList - OYLinkedlistImplementByOneWayLink" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkedlistimplementbytwowaylink" value="&#10;&#10;class Solution {&#10;    public class LinkedList&lt;E&gt; {&#10;        // 内部元素的个数&#10;        private int size;&#10;        // 指向第一个节点&#10;        private Node&lt;E&gt; first;&#10;        // 指向最后一个节点&#10;        private Node&lt;E&gt; last;&#10;        // 异常告警&#10;        private static final int VALUE_NOT_FOUND = -1;&#10;&#10;        // 构建Node节点类&#10;        private class Node&lt;E&gt; {&#10;            E value;&#10;            Node&lt;E&gt; prev;&#10;            Node&lt;E&gt; next;&#10;            public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next) {&#10;                this.prev = prev;&#10;                this.value = value;&#10;                this.next = next;&#10;            }&#10;        }&#10;&#10;        // 添加元素到尾部&#10;        public void add(E value) {&#10;            add(size, value);&#10;        }&#10;&#10;        // 在Index位置插入一个元素&#10;        public void add(int index, E value) {&#10;            rangeCheckForAdd(index);&#10;            if (index == size) {&#10;                // 往最后面添加元素&#10;                Node&lt;E&gt; oldLast = last;&#10;                last = new Node&lt;E&gt;(oldLast, value, null);&#10;                if (oldLast == null) {&#10;                    // 这是链表添加的第一个元素&#10;                    first = last;&#10;                } else {&#10;                    oldLast.next = last;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; next = node(index);&#10;                Node&lt;E&gt; prev = next.prev;&#10;                Node&lt;E&gt; node = new Node&lt;E&gt;(prev, value, next);&#10;                next.prev = node;&#10;&#10;                if (prev == null) {&#10;                    // 如果prev == null说明是index == 0&#10;                    first = node;&#10;                } else {&#10;                    prev.next = node;&#10;                }&#10;            }&#10;&#10;            size++;&#10;        }&#10;&#10;        // 清除所有元素&#10;        public void clear() {&#10;            size = 0;&#10;            first = null;&#10;            last = null;&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            Node&lt;E&gt; node = node(index);&#10;            Node&lt;E&gt; prev = node.prev;&#10;            Node&lt;E&gt; next = node.next;&#10;&#10;            if (prev == null) {&#10;                // 如果prev == null说明是index == 0&#10;                first = next;&#10;            } else {&#10;                prev.next = next;&#10;            }&#10;&#10;            if (next == null) {&#10;                // 删除最后一位index == size - 1&#10;                last = prev;&#10;            } else {&#10;                next.prev = prev;&#10;            }&#10;&#10;            size--;&#10;            return node.value;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            return node(index).value;&#10;        }&#10;&#10;        // 获取元素对应的index&#10;        public int indexOf(E value) {&#10;            if (value == null) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (node.value == null) return i;&#10;&#10;                    node = node.next;&#10;                }&#10;            } else {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (value.equals(node.value)) return i;&#10;&#10;                    node = node.next;&#10;                }&#10;            }&#10;            return VALUE_NOT_FOUND;&#10;        }&#10;&#10;        // 获取index位置对应的节点对象&#10;        private Node&lt;E&gt; node(int index) {&#10;            rangeCheck(index);&#10;&#10;            if (index &lt; (size &gt;&gt; 1)) {&#10;                Node&lt;E&gt; node = first;&#10;                for (int i = 0; i &lt; index; i++) {&#10;                    node = node.next;&#10;                }&#10;                return node;&#10;            } else {&#10;                Node&lt;E&gt; node = last;&#10;                for (int i = size - 1; i &gt; index; i--) {&#10;                    node = node.prev;&#10;                }&#10;                return node;&#10;            }&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E value) {&#10;            Node&lt;E&gt; node = node(index);&#10;            E old = node.value;&#10;            node.value = value;&#10;            return old;&#10;        }&#10;&#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 做加法抛出异常&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            Node&lt;E&gt; node = first;&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(node);&#10;                node = node.next;&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;}" description="链表 - 双向链表实现LinkedList - OYLinkedListImplementByTwoWayLink" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkjudgecircle" value="class Solution {&#10;    public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;    }&#10;&#10;&#10;    public boolean hasCycle(Node head) {&#10;        if (head == null || head.next == null) return false;&#10;        Node slow = head;&#10;        Node fast = head.next;&#10;&#10;        while (fast != null || fast.next != null){&#10;            if (slow == fast) return true;&#10;            slow = slow.next;&#10;            fast = fast.next.next;&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" description="链表 - 判断链表是否有环 - OYLinkJudgeCircle" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkjudgepalindrome" value="import java.util.*;&#10;&#10;class Solution{&#10;    public static class Node {&#10;        public int value;&#10;        public Node next;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // need n extra space&#10;    public static boolean isPalindrome1(Node head) {&#10;        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;        Node cur = head;&#10;        while (cur != null) {&#10;            stack.push(cur);&#10;            cur = cur.next;&#10;        }&#10;        while (head != null) {&#10;            if (head.value != stack.pop().value) {&#10;                return false;&#10;            }&#10;            head = head.next;&#10;        }&#10;        return true;&#10;    }&#10;}" description="链表 - 判断一个链表是否为回文结构 - OYLinkJudgePalindrome" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkprintcommonpart" value="public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node next;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void printCommonPart(Node head1, Node head2) {&#10;        System.out.print(&quot;Common Part: &quot;);&#10;        while (head1 != null &amp;&amp; head2 != null) {&#10;            if (head1.value &lt; head2.value) {&#10;                head1 = head1.next;&#10;            } else if (head1.value &gt; head2.value) {&#10;                head2 = head2.next;&#10;            } else {&#10;                System.out.print(head1.value + &quot; &quot;);&#10;                head1 = head1.next;&#10;                head2 = head2.next;&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    public static void printLinkedList(Node node) {&#10;        System.out.print(&quot;Linked List: &quot;);&#10;        while (node != null) {&#10;            System.out.print(node.value + &quot; &quot;);&#10;            node = node.next;&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        Node node1 = new Node(2);&#10;        node1.next = new Node(3);&#10;        node1.next.next = new Node(5);&#10;        node1.next.next.next = new Node(6);&#10;&#10;        Node node2 = new Node(1);&#10;        node2.next = new Node(2);&#10;        node2.next.next = new Node(5);&#10;        node2.next.next.next = new Node(7);&#10;        node2.next.next.next.next = new Node(8);&#10;&#10;        printLinkedList(node1);&#10;        printLinkedList(node2);&#10;        printCommonPart(node1, node2);&#10;&#10;    }&#10;}&#10;&#10;" description="链表 - 打印两个有序链表的公共部分 - OYLinkPrintCommonPart" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oylinkreverse" value="class Solution {&#10;    public class Node {&#10;        int value;&#10;        Node next;&#10;        Node(int x) { value = x; }&#10;    }&#10;&#10;    // 递归解法&#10;    public Node reverseList1(Node head) {&#10;        if(head == null || head.next == null) return head;&#10;&#10;        Node newHead = reverseList1(head.next);&#10;        head.next.next = head;&#10;        head.next = null;&#10;        return newHead;&#10;    }&#10;&#10;    // 非递归解法&#10;    public Node reverseList2(Node head) {&#10;        if (head == null || head.next == null) return  head;&#10;&#10;        Node newHead = null;&#10;        while (head != null){&#10;            Node tmpNode = head.next;&#10;            head.next = newHead;&#10;            newHead = head;&#10;            head = tmpNode;&#10;        }&#10;        return newHead;&#10;    }&#10;}" description="链表 - 反转链表 - OYLinkReverse" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>