<templateSet group="Algorithm-Tree">
  <template name="oytree-find-behind-node" value="import java.util.*;&#10;&#10;/* 解题规律:&#10; * 1.首先我们要明白后继节点值得是,在二叉树终须遍历序列中,node的下一个节点叫做node的后继节点&#10; * 2.如果节点X有右子树,那么该节点的后继节点一定是其右子树最左的节点(结合中序遍历思考得出);&#10; * 3.如果节点X没有右子树，通过节点X的Parent指针找节点X的父节点,一直往上找，直到节点X是该某个节点的左孩子，那么这个某个节点就是X节点的后继节点&#10; */&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;        public Node parent;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static Node getSuccessorNode(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;&#10;        if (node.right != null) {&#10;            //如果一个节点有右子树,直接找到这颗右子树上最左的节点&#10;            return getLeftMost(node.right);&#10;        } else {&#10;            Node parent = node.parent;&#10;            //parent != null处理边界值，parent.left != node当前节点等于自己的左孩子停&#10;            while (parent != null &amp;&amp; parent.left != node) {&#10;                node = parent;&#10;                parent = node.parent;&#10;            }&#10;            return parent;&#10;        }&#10;    }&#10;&#10;    //拿到右子树上最左的节点&#10;    public static Node getLeftMost(Node node) {&#10;        if (node == null) {&#10;            return node;&#10;        }&#10;        while (node.left != null) {&#10;            node = node.left;&#10;        }&#10;        return node;&#10;    }&#10;}" description="二叉树 - 查找后继节点 - OYTreeFindBehindNode" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-inorder" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    //递归&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        System.out.print(head.value + &quot; &quot;);&#10;        inOrderRecur(head.right);&#10;    }&#10;&#10;    //非递归&#10;    public static void inOrderUnRecur(Node head) {&#10;        System.out.print(&quot;in-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();//左根右&#10;            //！stack.isEmpty这个条件只是用来判断是否结束而已，关键的是head != null这个条件&#10;            while (!stack.isEmpty() || head != null) {&#10;                //如果当前节点不为空将当前节点压入栈然后当前节点往左;当前节点为空从栈拿一个打印，然后当前节点往右边跑&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                } else {&#10;                    //把当前节点指向了从栈弹出的那个节点&#10;                    head = stack.pop();&#10;                    System.out.print(head.value + &quot; &quot;);&#10;                    head = head.right;&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 中序遍历 - OYTreeInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-judge-balance" value="/*&#10; * 判断一颗二叉树是否是平衡二叉树，它是一棵空树或任意节点左右两个子树的高度差的绝对值不超过1称为平衡二叉树&#10; *&#10; * 这道题目充分体现了递归对于解决树相关算法题的作用,如果我们抛开先序中序后序的打印时机,其实递归来到每个节点的次数是三次&#10; * 我既然可以回到要给节点三次,我们就可以收集左子树和右子树的信息,最后回到根节点,进行判断,可以总结为一个高度解题套路&#10; * 譬如我为了判断X为根节点的树是不是平衡树,我们可以先判断节点X的左树是否平衡,右树是否平衡,然后获取左树高度和右树高度比较是否超过1&#10; * 套路就是要设计我们的递归返回结构,对于这道题来说我们需要递归函数给我们返回信息包括了这棵树是否平衡和这棵树高度;&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 设计递归的返回结构&#10;    public static class ReturnData{&#10;        // 是否是平衡二叉树&#10;        public boolean isBalance;&#10;        // 树的高度&#10;        public int height;&#10;&#10;        public ReturnData(boolean isBalance,int height){&#10;            this.isBalance = isBalance;&#10;            this.height = height;&#10;        }&#10;    }&#10;&#10;    public static boolean isBalanceTree(Node head) {&#10;        return process(head).isBalance;&#10;    }&#10;&#10;    // 设计递归函数,返回信息包括该树是否是平衡二叉树以及该树的高度&#10;    public static ReturnData process(Node head){&#10;        // 如果是空树认为也算是平衡二叉树&#10;        if(head == null){&#10;            return new ReturnData(true,0);&#10;        }&#10;        ReturnData leftData = process(head.left);&#10;        // 如果左树已经是不平衡直接返回不平衡&#10;        if(!leftData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        ReturnData rightData = process(head.right);&#10;        // 如果右树已经是不平衡直接返回不平衡&#10;        if(!rightData.isBalance){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // 说明左树和右树都已经平衡了&#10;        if(Math.abs(leftData.height - rightData.height) &gt; 1){&#10;            return new ReturnData(false,0);&#10;        }&#10;        // return在递归中很重要,左树和右树高度较大的那个加1就是我自己的高度&#10;        return new ReturnData(true,Math.max(leftData.height , rightData.height) + 1);&#10;    }&#10;&#10;}&#10;" description="二叉树 - 判断平衡二叉树 - OYTreeJudgeBalance" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-judge-complete" value="import java.util.*;&#10;&#10;/* 如何判断一个数是否是完全二叉树,按层一个节点一个节点遍历,每个节点需要满足下面两个条件&#10; * 第一阶段：如果一个节点只有右孩子没有左孩子绝对不是完全二叉树,可以直接返回false&#10; * 第二阶段：如果一个节点不是左右两个孩子都全(那么这里要么是有左孩子没有右孩子要么是左右都没有孩子)，&#10; *         那么在这样的情况下按层遍历如果未遍历的节点都是叶子节点则说明是完全二叉树&#10; */&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean isCompleteBinaryTree(Node head) {&#10;        if (head == null) {&#10;            return true;&#10;        }&#10;        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();&#10;        //标志是否进入了第二阶段，开启后续节点都是叶节点的这样一个阶段&#10;        boolean leaf = false;&#10;        Node l = null;&#10;        Node r = null;&#10;        queue.offer(head);&#10;        while (!queue.isEmpty()) {&#10;            head = queue.poll();&#10;            l = head.left;&#10;            r = head.right;&#10;            //这个if语句中有两个判断条件：&#10;            //第一个条件：如果我开启了第二阶段了 并且左孩子不为空或者右孩子不为空 (标准二)&#10;            //第二个条件：左孩子为空，右孩子也不为空(标准一)&#10;            if ((leaf &amp;&amp; (l != null || r != null))&#10;                    ||&#10;                    (l == null &amp;&amp; r != null)){&#10;                return false;&#10;            }&#10;            if (l != null) {&#10;                queue.offer(l);&#10;            }&#10;            if (r != null) {&#10;                queue.offer(r);&#10;            }&#10;            if (l == null || r == null) {&#10;                //进入第二阶段&#10;                leaf = true;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="二叉树 - 判断完全二叉树 - OYTreeJudgeComplete" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-judge-search" value="import java.util.*;&#10;&#10;/*&#10; * 判断一棵树是否是搜索二叉树，左子树值比自己小，右子树值比自己大。其实只要满足二叉树中序遍历结果是依次升序的就是搜索二叉树&#10; */&#10;&#10;public class Solution {&#10;&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static boolean inOrderUnRecur(Node head) {&#10;        if (head != null) {&#10;            int pre = 0;&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            while(!stack.isEmpty() || head != null) {&#10;                if (head != null) {&#10;                    stack.push(head);&#10;                    head = head.left;&#10;                }else {&#10;                    stack.pop();&#10;                    // 当前这个数是否比前一个数小则不满足搜索二叉树&#10;                    if (head.value &lt; pre){&#10;                        return false;&#10;                    }&#10;                    head = head.right;&#10;                }&#10;            }&#10;            return true;&#10;        }&#10;    }&#10;}" description="二叉树 - 判断搜索二叉树 - OYTreeJudgeSearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-level-order" value="public class Solution {&#10;    public static class Node {&#10;        int  value;&#10;        Node left;&#10;        Node right;&#10;&#10;        public Node(int data){&#10;            this.value = data;&#10;        }&#10;    }&#10;    &#10;    public static void levelRead(Node head) {&#10;        // 当结点非空时才进行操作&#10;        if (head != null) {&#10;            // 用于存放还未遍历的元素&#10;            LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;();&#10;            // 将根结点入队&#10;            queue.add(head);&#10;            // 用于记录当前处理的结点&#10;            //Node head;&#10;&#10;            // 队列非空则进行处理&#10;            while (!queue.isEmpty()) {&#10;                // remove()表示删除队首元素&#10;                head = queue.remove();&#10;                // 输出队首元素的值&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 如果左子结点不为空，则左子结点入队&#10;                if (head.left != null) {&#10;                    queue.add(head.left);&#10;                }&#10;                // 如果右子结点不为空，则左子结点入队&#10;                if (head.right != null) {&#10;                    queue.add(head.right);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" description="二叉树 -  层序遍历 -OYTreeLevelOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-pos-order" value="import java.util.*;&#10;&#10;public class Solution {&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    public static void inOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        inOrderRecur(head.left);&#10;        inOrderRecur(head.right);&#10;        System.out.print(head.value + &quot; &quot;);&#10;    }&#10;&#10;    public static void posOrderUnRecur1(Node head) {&#10;        System.out.print(&quot;pos-order: &quot;);&#10;        if (head != null) {&#10;            Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();&#10;            Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();&#10;            s1.push(head);&#10;            while (!s1.isEmpty()) {&#10;                head = s1.pop();&#10;                s2.push(head);&#10;                //本来是打印的时机，但你先不打印全部先放到辅助栈s2&#10;                if (head.left != null) {&#10;                    s1.push(head.left);&#10;                }&#10;                if (head.right != null) {&#10;                    s1.push(head.right);&#10;                }&#10;            }&#10;            //再打印栈s2&#10;            while (!s2.isEmpty()) {&#10;                System.out.print(s2.pop().value + &quot; &quot;);&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 后序遍历 -OYTreePosOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oytree-pre-order" value="import java.util.*;&#10;&#10;public class Solution {&#10;    // 节点的基本构造&#10;    public static class Node {&#10;        public int value;&#10;        public Node left;&#10;        public Node right;&#10;&#10;        public Node(int data) {&#10;            this.value = data;&#10;        }&#10;    }&#10;&#10;    // 递归前序遍历&#10;    public static void preOrderRecur(Node head) {&#10;        if (head == null) {&#10;            return;&#10;        }&#10;        System.out.print(head.value + &quot; &quot;);&#10;        preOrderRecur(head.left);&#10;        preOrderRecur(head.right);&#10;    }&#10;&#10;    // 非递归前序遍历&#10;    public static void preOrderUnRecur(Node head) {&#10;        System.out.print(&quot;pre-order: &quot;);&#10;        if (head != null) {&#10;            // 采用栈结构&#10;            Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();&#10;            stack.add(head);&#10;            while (!stack.isEmpty()) {&#10;                // 这里的head是复用的，表示当前节点&#10;                head = stack.pop();&#10;                System.out.print(head.value + &quot; &quot;);&#10;                // 整体的顺序是先压右后压左&#10;                if (head.right != null) {&#10;                    stack.push(head.right);&#10;                }&#10;                if (head.left != null) {&#10;                    stack.push(head.left);&#10;                }&#10;            }&#10;        }&#10;        System.out.println();&#10;    }&#10;}" description="二叉树 - 前序遍历 - OYTreePreOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>