<templateSet group="Algorithm-Array">
  <template name="oyarray-sort-bubble" value="public class Solution {&#10;    public static void bubbleSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;&#10;        for (int end = arr.length -1; end &gt; 0; end--){&#10;            //设置这一趟并未发生交换&#10;            boolean exchange = false;&#10;            for (int i = 0; i &lt; end; i++){&#10;                if (arr[i] &gt; arr[i+1]){&#10;                    swap(arr, i, i + 1);&#10;                    //已经发生交换&#10;                    exchange = true;&#10;                }&#10;            }&#10;            //如果没有发生交换则break说明前面都已经排序完毕，节省没必要的比较&#10;            if (!exchange) break;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 冒泡排序 - OYArraySortBubble" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-selection" value="public class Solution {&#10;    public static void selectionSort(int[] arr){&#10;        if(arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        //i &lt; length - 1数组的最后一位没有必要再进行比较&#10;        for (int i = 0; i &lt; arr.length - 1; i++){&#10;            //我定义的最小值的Index&#10;            int minIndex = i;&#10;            //这里就可以说j对于i是不变的，虽然i是变的；j其实是每一趟的起始值&#10;            for (int j = i + 1;j &lt; arr.length;j++){&#10;                //实际找到的minIndex&#10;                minIndex = arr[j] &lt; arr[minIndex] ? j:minIndex;&#10;            }&#10;            swap(arr, i, minIndex);&#10;        }&#10;    }&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j){&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;    //打印数组的每一个元素出来&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);//这里加空格&#10;        }&#10;        //下面这句总体换一行，细节真的很关键&#10;        System.out.println();&#10;    }&#10;}" description="数组 - 选择排序 - OYArraySortSelection" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-insert" value="public class Solution {&#10;    public static void insertSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        for (int i = 1; i &lt; arr.length; i++) {&#10;            //就像打扑克牌排序一样插入排序，一张牌来了，从右往左遍历&#10;            for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {&#10;                swap(arr, j, j + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    //交换数组中两个元素&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int temp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = temp;&#10;    }&#10;}" description="数组 - 插入排序 - OYArraySortInsert" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-merge" value="public class Solution {&#10;    public static void mergeSort(int[] arr){&#10;        if (arr == null || arr.length &lt; 2){&#10;            return;&#10;        }&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int l,int r){&#10;        if(l == r){&#10;            return;&#10;        }&#10;        int mid = l + ((r - l) &gt;&gt; 1);&#10;        mergeSort(arr, l, mid);&#10;        mergeSort(arr, mid+1, r);&#10;        merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static void merge(int[] arr, int l, int m, int r){&#10;        int[] help = new int[r - l + 1];&#10;        int i = 0;&#10;        int p1 = l;&#10;        int p2 = m + 1;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r){&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        while (p1 &lt;= m){&#10;            help[i++] = arr[p1++];&#10;        }&#10;        while (p2 &lt;= r){&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++){&#10;            arr[l + i] = help[i];&#10;        }&#10;    }&#10;}&#10;" description="数组 - 归并排序 - OYArraySortMerge" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-quick" value="public class Solution {&#10;    public static void quickSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        quickSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void quickSort(int[] arr, int L, int R) {&#10;        //这个条件很重要,整个过程必须要在L&lt;R下进行&#10;        if (L &lt; R) {&#10;            //随机选择一个数和最后一个数交换，然后采用最后一位数做标志位&#10;            swap(arr, L + (int) (Math.random() * (R - L + 1)), R);&#10;            int[] p = partition(arr, L, R);&#10;            //递归遍历,每次确定中间的一片数字&#10;            quickSort(arr, L, p[0] - 1);&#10;            quickSort(arr, p[1] + 1, R);&#10;        }&#10;    }&#10;&#10;    public static int[] partition(int[] arr, int L, int R) {&#10;        int less = L - 1;&#10;        int more = R;&#10;        int cur = L;&#10;        //把数组的最后一位当成了Partition问题中的比较数字&#10;        while (cur &lt; more) {&#10;            if (arr[cur] &lt; arr[R]) {&#10;                swap(arr, ++less, cur++);&#10;            } else if (arr[cur] &gt; arr[R]) {&#10;                swap(arr, --more, cur);&#10;            } else {&#10;                cur++;&#10;            }&#10;        }&#10;        //因为最后一位并没有参与遍历此时数组的划分为 &lt;X | =X | &gt;X | X 四个区域&#10;        //为此我们要通过swap函数交换为 &lt;X | =X | &gt;X 三个区域&#10;        swap(arr, more, R);&#10;        //返回等于区域相应的下标&#10;        return new int[] { less + 1, more };&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}&#10;" description="数组 - 快速排序 - OYArraySortQuick" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-Heap" value="import java.util.Arrays;&#10;&#10;&#10;public class Solution {&#10;&#10;    public static void heapSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        // 下面这一步后整个数组就是大根堆结构了&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            // 依次把i位置上的数加进来，让他从0-i位置上称为大根堆&#10;            heapInsert(arr, i);&#10;        }&#10;        int heapSize = arr.length;&#10;&#10;        // 将堆顶与堆底最后一个数字交换&#10;        swap(arr, 0, --heapSize);&#10;&#10;        while (heapSize &gt; 0) {&#10;            // 每次都修正整个堆，让堆顶是最大的数字&#10;            heapify(arr, 0, heapSize);&#10;            // 将堆顶与heapSize最后一个数交换,每次交换都缩小heapSize的范围，将已经排序完毕的数字排出去&#10;            swap(arr, 0, --heapSize);&#10;        }&#10;    }&#10;&#10;    //建立大根堆,把数组变为大根堆结构,index表示即将要加进来的节点&#10;    public static void heapInsert(int[] arr, int index) {&#10;        // while循环将子节点比父节点大的节点提上来&#10;        while (arr[index] &gt; arr[(index - 1) / 2]) {&#10;            // 当前我比我的父位置要大，则交换&#10;            swap(arr, index, (index - 1) / 2);&#10;            // 交换完之后继续与父位置进行比较直到满足大根堆&#10;            // 此处精妙之处在于当节点一直跳到最顶的节点那么会变成arr[0]与arr[(0-1)/2]比较，则必定相等跳出循环&#10;            index = (index - 1) / 2;&#10;        }&#10;    }&#10;&#10;    // 修正数组为堆结构,这个函数的意思是在0 ~ heapSize-1我认为形成了堆，除了这个范围我认为越界；&#10;    // index的值发生了变小了，导致index这个节点应该往下沉&#10;    // heapSize的意思是整个堆上有多少个数，与数组个数并没有关系，但一定不会比数组个数大；&#10;    public static void heapify(int[] arr, int index, int heapSize) {&#10;        int left = index * 2 + 1;&#10;        //while成立条件是我的左还是还在堆上&#10;        while (left &lt; heapSize) {&#10;            //找出左右节点最大值的下标，left + 1表示右孩子;只有你有右孩子并且右孩子比左孩子要大那么largest才是右孩子&#10;            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left]&#10;                    ? left + 1&#10;                    : left;&#10;            //找到左右节点最大值与父节点比较找到最大值下标，并将其作为largest&#10;            largest = arr[largest] &gt; arr[index] ? largest : index;&#10;            //如果发现最大值是自己则不需要交换break&#10;            if (largest == index) {&#10;                break;&#10;            }&#10;            //largest != index&#10;            swap(arr, largest, index);&#10;            index = largest;&#10;            //left又往下走重复整个while循环&#10;            left = index * 2 + 1;&#10;        }&#10;    }&#10;&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 堆排序 - OYArraySortHeap" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-nixudui" value="public class Solution {&#10;    public static void niXuDui(int[] arr) {&#10;        if(arr == null || arr.length &lt; 2)&#10;            return;&#10;&#10;        mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static void mergeSort(int[] arr, int L, int R) {&#10;        if(L == R) {&#10;            return;&#10;        }&#10;&#10;        int mid = L + (R - L) / 2;&#10;        mergeSort(arr, L, mid);&#10;        mergeSort(arr, mid + 1, R);&#10;        merge(arr, L, mid, R);&#10;    }&#10;&#10;    public static void merge(int[] arr, int L, int m, int R) {&#10;        int[] help = new int[R - L + 1];&#10;        int i = 0;&#10;        int p1 = L;&#10;        int p2 = m + 1;&#10;&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= R) {&#10;            // 如果这个条件成立，那么左半部分的所有数一定大于右半部分&#10;            if(arr[p1] &gt; arr[p2]) {&#10;                for(int j = p1; j &lt;= m; j++) {&#10;                    System.out.println(arr[j] + &quot;, &quot; + arr[p2]);&#10;                }&#10;            }&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;&#10;        while (p2 &lt;= R) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;&#10;        for(i = 0; i &lt; help.length; i++) {&#10;            arr[L + i] = help[i];&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] a = {1, 3, 4, 2, 5};&#10;        niXuDui(a);&#10;&#10;    }&#10;}" description="数组 - 归并衍生的逆序对 - OYArrayMergenixudui" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-merge-minsum" value="public class Solution {&#10;    public static int smallSum(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        return mergeSort(arr, 0, arr.length - 1);&#10;    }&#10;&#10;    public static int mergeSort(int[] arr, int l, int r) {&#10;        if (l == r) {&#10;            return 0;&#10;        }&#10;        int mid = l + (r - l) &gt;&gt; 1;&#10;        // 左边产生的小和+右边产生的小和+合并产生的小和就是整个数组的小和&#10;        return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);&#10;    }&#10;&#10;    public static int merge(int[] arr, int l, int m, int r) {&#10;        // 辅助数组&#10;        int[] help = new int[r - l + 1];&#10;        // 辅助数组下标&#10;        int i = 0;&#10;        // 左半边数组的指针&#10;        int p1 = l;&#10;        // 右半边数组的指针&#10;        int p2 = m + 1;&#10;        // 小和&#10;        int res = 0;&#10;        // 指针没有越界&#10;        while (p1 &lt;= m &amp;&amp; p2 &lt;= r) {&#10;            // 如果左边指向的值小于右边指向的值，那么p1位置的值一定小于p2以后的所有值，因为是有序的，这时候产生小和&#10;            res += arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#10;            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#10;        }&#10;        // p1没有越界，说明p2越界了，将左边剩余元素拷贝到辅助数组&#10;        while (p1 &lt;= m) {&#10;            help[i++] = arr[p1++];&#10;        }&#10;        // p2没有越界，说明p1越界了&#10;        while (p2 &lt;= r) {&#10;            help[i++] = arr[p2++];&#10;        }&#10;        // 将辅助数组元素拷贝会原数组&#10;        for (i = 0; i &lt; help.length; i++) {&#10;            arr[l + i] = help[i];&#10;        }&#10;        return res;&#10;    }&#10;}" description="数组 - 归并衍生的小和问题 - OYArrayMergeMinSum" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-dutch-flag" value="public class Solution {&#10;    public static int[] partition(int[] arr, int l, int r, int p) {&#10;        //less,more 分别是少于和大于的区域指针&#10;        int less = l - 1;&#10;        int more = r + 1;&#10;        int cur = l;&#10;        while (cur &lt; more) {&#10;            //当前位置的数如果少于P就和少于区域的下一个交换&#10;            //如果大于P就和大于区域的前一个交换&#10;            //如果等于就直接跳到下一个&#10;            if (arr[cur] &lt; p) {&#10;                swap(arr, ++less, l++);&#10;            } else if (arr[cur] &gt; p) {&#10;                //因为刚交换过来的数还不知道大小，所以应该先判断，而需要指向下一个&#10;                swap(arr, --more, cur);&#10;            } else {&#10;                cur++;&#10;            }&#10;        }&#10;        return new int[] { less + 1, more - 1 };&#10;    }&#10;&#10;    // for test&#10;    public static void swap(int[] arr, int i, int j) {&#10;        int tmp = arr[i];&#10;        arr[i] = arr[j];&#10;        arr[j] = tmp;&#10;    }&#10;}" description="数组 - 荷兰国旗问题 - OYArrayDutchFlag" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-fibonacci" value="//非递归算法&#10;public static long Fib(long num){&#10;    long first = 0;&#10;    long second = 1;&#10;    long third = 0;&#10;    for (int i = 2; i &lt;= num; i++){&#10;        third = first + second;&#10;        first = second;&#10;        second = third;&#10;    }&#10;    return third;&#10;}&#10;&#10;//递归算法&#10;public static long Fib(long num){&#10;    if ((num == 1) || num == 0){&#10;        return num;&#10;    }&#10;    return Fib(num - 1) + Fib(num - 2);&#10;}&#10;// 递归缺点：可能导致栈溢出，时间复杂度太高为大O2的n次方。" description="数组 - 斐波那契数列 - OYArrayFibonacci" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-search-binary" value="public class Solution {&#10;    public static int commonBinarySearch(int[] arr,int target) {&#10;        int low = 0;&#10;        int high = arr.length - 1;&#10;        int middle = 0;&#10;&#10;        if (low &gt; high || target &lt; arr[low] || target &gt; arr[high]) {&#10;            return -1;&#10;        }&#10;        while (low &lt;= high){&#10;            middle = (high + low)/2;&#10;            if (arr[middle] &lt; target){&#10;                low = middle + 1;&#10;            }else if (arr[middle] &gt; target){&#10;                high = middle - 1;&#10;            }else {&#10;                return middle;&#10;            }&#10;        }&#10;        return -1;&#10;    }&#10;}" description="数组 - 二分查找 - OYArrayBinarySearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-sort-bucket" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    // only for 0~200 value&#10;    public static void bucketSort(int[] arr) {&#10;        if (arr == null || arr.length &lt; 2) {&#10;            return;&#10;        }&#10;        int max = Integer.MIN_VALUE;&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            max = Math.max(max, arr[i]);&#10;        }&#10;        int[] bucket = new int[max + 1];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            bucket[arr[i]]++;&#10;        }&#10;        int i = 0;&#10;        for (int j = 0; j &lt; bucket.length; j++) {&#10;            while (bucket[j]-- &gt; 0) {&#10;                arr[i++] = j;&#10;            }&#10;        }&#10;    }&#10;&#10;    // for test&#10;    public static void comparator(int[] arr) {&#10;        Arrays.sort(arr);&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static boolean isEqual(int[] arr1, int[] arr2) {&#10;        if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {&#10;            return false;&#10;        }&#10;        if (arr1 == null &amp;&amp; arr2 == null) {&#10;            return true;&#10;        }&#10;        if (arr1.length != arr2.length) {&#10;            return false;&#10;        }&#10;        for (int i = 0; i &lt; arr1.length; i++) {&#10;            if (arr1[i] != arr2[i]) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    // for test&#10;    public static void printArray(int[] arr) {&#10;        if (arr == null) {&#10;            return;&#10;        }&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            System.out.print(arr[i] + &quot; &quot;);&#10;        }&#10;        System.out.println();&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 150;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            bucketSort(arr1);&#10;            comparator(arr2);&#10;            if (!isEqual(arr1, arr2)) {&#10;                succeed = false;&#10;                printArray(arr1);&#10;                printArray(arr2);&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;&#10;        int[] arr = generateRandomArray(maxSize, maxValue);&#10;        printArray(arr);&#10;        bucketSort(arr);&#10;        printArray(arr);&#10;    }&#10;&#10;}" description="数组 - 桶排序 - OYArraySortBucket" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-bucket-difference" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;&#10;    public static int maxGap(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        int len = nums.length;&#10;        int min = Integer.MAX_VALUE;&#10;        int max = Integer.MIN_VALUE;&#10;        // 获取数组中最大和最小的数字&#10;        for (int i = 0; i &lt; len; i++) {&#10;            min = Math.min(min, nums[i]);&#10;            max = Math.max(max, nums[i]);&#10;        }&#10;        if (min == max) {&#10;            return 0;&#10;        }&#10;        // 开始建立桶,每个桶需要存放的信息是这个桶的最大值最小值已经是否有存放数字&#10;        boolean[] hasNum = new boolean[len + 1];&#10;        int[] maxs = new int[len + 1];&#10;        int[] mins = new int[len + 1];&#10;        int bid = 0;&#10;        // 开始遍历保证当前桶的最小值距离左边有存放数字的桶的最大值的差值，记录下来&#10;        for (int i = 0; i &lt; len; i++) {&#10;            bid = bucket(nums[i], len, min, max);&#10;            mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];&#10;            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];&#10;            hasNum[bid] = true;&#10;        }&#10;        int res = 0;&#10;        int lastMax = maxs[0];&#10;        int i = 1;&#10;        for (; i &lt;= len; i++) {&#10;            if (hasNum[i]) {&#10;                res = Math.max(res, mins[i] - lastMax);&#10;                lastMax = maxs[i];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;    // 定位一个数是属于几号桶&#10;    public static int bucket(long num, long len, long min, long max) {&#10;        return (int) ((num - min) * len / (max - min));&#10;    }&#10;&#10;    // for test&#10;    public static int comparator(int[] nums) {&#10;        if (nums == null || nums.length &lt; 2) {&#10;            return 0;&#10;        }&#10;        Arrays.sort(nums);&#10;        int gap = Integer.MIN_VALUE;&#10;        for (int i = 1; i &lt; nums.length; i++) {&#10;            gap = Math.max(nums[i] - nums[i - 1], gap);&#10;        }&#10;        return gap;&#10;    }&#10;&#10;    // for test&#10;    public static int[] generateRandomArray(int maxSize, int maxValue) {&#10;        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());&#10;        }&#10;        return arr;&#10;    }&#10;&#10;    // for test&#10;    public static int[] copyArray(int[] arr) {&#10;        if (arr == null) {&#10;            return null;&#10;        }&#10;        int[] res = new int[arr.length];&#10;        for (int i = 0; i &lt; arr.length; i++) {&#10;            res[i] = arr[i];&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // for test&#10;    public static void main(String[] args) {&#10;        int testTime = 500000;&#10;        int maxSize = 100;&#10;        int maxValue = 100;&#10;        boolean succeed = true;&#10;        for (int i = 0; i &lt; testTime; i++) {&#10;            int[] arr1 = generateRandomArray(maxSize, maxValue);&#10;            int[] arr2 = copyArray(arr1);&#10;            if (maxGap(arr1) != comparator(arr2)) {&#10;                succeed = false;&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(succeed ? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;);&#10;    }&#10;&#10;}&#10;" description="数组 - 桶排序衍生的相邻数最大差 - OYArrayBucketMaxDifference" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-merge-order" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;    /*&#10;     * arr1表示数组1   m表示arr1的长度&#10;     * arr2表示数组2   n表示arr2的长度&#10;     * */&#10;    public static void merge(int[] arr1, int m, int[] arr2, int n) {&#10;        //新数组下标以及新数组&#10;        int arrIndex = 0;&#10;        int[] arr = new int[m+n];&#10;&#10;        //双指针&#10;        int i = 0;&#10;        int j = 0;&#10;        while (i &lt; m &amp;&amp; j &lt; n ){&#10;            if (arr1[i] &lt;= arr2[j])&#10;                arr[arrIndex++] = arr1[i++];&#10;            else&#10;                arr[arrIndex++] = arr2[j++];&#10;        }&#10;&#10;        if (i &lt; m)&#10;            while (i&lt;m)&#10;                arr[arrIndex++] = arr1[i++];&#10;&#10;        if (j &lt; n)&#10;            while (j&lt;n)&#10;                arr[arrIndex++] = arr2[j++];&#10;        //把arr中从0开始的长度为整个数组的所有的数放到arr1中去&#10;        System.arraycopy(arr,0,arr1,0,arr.length);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] num1 = {1,2,3,0,0,0};&#10;        int[] num2 = {2,5,6};&#10;        int m = 3; int n = 3;&#10;        merge(num1,m,num2,n);&#10;        System.out.println(Arrays.toString(num1));&#10;    }&#10;}&#10;" description="数组 - 合并有序数组 - OYArrayMergeOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-two-sum" value="import java.util.Arrays;&#10;&#10;public class Solution {&#10;    public static int[] twoSum(int[] arr, int target) {&#10;        HashMap&lt;Integer,Integer&gt;  map = new HashMap&lt;&gt;();&#10;        for (int i = 0; i &lt; arr.length;i++){&#10;            //找到该数字的组合数&#10;            int complement = target - arr[i];&#10;            //在map中寻找是否有这个key了,有直接返回&#10;            if (map.containsKey(complement)){&#10;                return new int[] { map.get(complement),i };&#10;            }&#10;            //map中不存在老老实实将以数组的值为key,索引i为value;&#10;            map.put(arr[i],i);&#10;        }&#10;        //抛出异常&#10;        throw new IllegalArgumentException(&quot;No two sum Solution&quot;);&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        int[] arr = {5,3,2,9,7};&#10;        int target = 7;&#10;        int[] result = twoSum(arr,target);&#10;        System.out.println(Arrays.toString(result));&#10;    }&#10;}&#10;" description="数组 - 两数之和 - OYArrayTwoSum" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-two-dimension-search" value="/*&#10; *  在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&#10; * 请完 成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&#10; * 思路：从右上角或左下角开始找，逐行删除，或者用二分法查找&#10; */&#10;public class Solution {&#10;    public static boolean findNum(int[][] arr,int target){&#10;        //基本条件判断&#10;        if (arr == null || arr.length &lt; 1 || arr[0].length &lt; 1){&#10;            return false;&#10;        }&#10;&#10;        int row = 0;&#10;        int column = arr[0].length - 1;&#10;        //保证行列边界&#10;        while(row &lt; arr.length &amp;&amp; column &gt;= 0){&#10;            if (arr[row][column] &lt; target){&#10;                row++;&#10;            } else if (arr[row][column] &gt; target){&#10;                column-- ;&#10;            } else{&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;}" description="数组 - 二维数组中查找 - OYArrayTwoDimensionSearch" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarraylist-implement-by-array" value="public class Solution {&#10;    public static class ArrayList&lt;E&gt; {&#10;        // 数组当前可容纳容量&#10;        private int size;&#10;        // 维护一个内部数组&#10;        private E[] elements;&#10;        // 数组默认长度&#10;        private static final int DEFAULT_CAPACITY = 10;&#10;        // 异常告警&#10;        private static final int ELEMENT_NOT_FOUND = -1;&#10;&#10;        //构造函数&#10;        public ArrayList(int capaticy) {&#10;            capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;&#10;            elements = (E[]) new Object[capaticy];&#10;        }&#10;        public ArrayList() {&#10;            this(DEFAULT_CAPACITY);&#10;        }&#10;&#10;        // 在index位置插入一个元素&#10;        public void add(int index, E element) {&#10;            rangeCheckForAdd(index);&#10;            ensureCapacity(size + 1);&#10;&#10;            for (int i = size; i &gt; index; i--) {&#10;                elements[i] = elements[i - 1];&#10;            }&#10;            elements[index] = element;&#10;            size++;&#10;        }&#10;&#10;        // 添加元素到尾部&#10;        public void add(E element) {&#10;            add(size, element);&#10;        }&#10;&#10;        // 删除index位置的元素&#10;        public E remove(int index) {&#10;            rangeCheck(index);&#10;&#10;            E old = elements[index];&#10;            for (int i = index + 1; i &lt; size; i++) {&#10;                elements[i - 1] = elements[i];&#10;            }&#10;            elements[--size] = null;&#10;&#10;            trim();&#10;&#10;            return old;&#10;        }&#10;&#10;        // 清除所有元素&#10;        public void clear() {&#10;            for (int i = 0; i &lt; size; i++) {&#10;                elements[i] = null;&#10;            }&#10;            size = 0;&#10;        }&#10;&#10;        // 设置index位置的元素&#10;        public E set(int index, E element) {&#10;            rangeCheck(index);&#10;            E old = elements[index];&#10;            elements[index] = element;&#10;            return old;&#10;        }&#10;&#10;        // 获取index位置的元素&#10;        public E get(int index) {&#10;            rangeCheck(index);&#10;            return elements[index];&#10;        }&#10;&#10;        // 是否包含某个元素&#10;        public boolean contains(E element) {&#10;            return indexOf(element) != ELEMENT_NOT_FOUND;&#10;        }&#10;&#10;        // 元素的数量&#10;        public int size() {&#10;            return size;&#10;        }&#10;&#10;        // 是否为空&#10;        public boolean isEmpty() {&#10;            return size == 0;&#10;        }&#10;&#10;        // 保证要有capacity的容量&#10;        private void ensureCapacity(int capacity) {&#10;            int oldCapacity = elements.length;&#10;            if (oldCapacity &gt;= capacity) return;&#10;&#10;            // 新容量为旧容量的1.5倍&#10;            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);&#10;            E[] newElements = (E[]) new Object[newCapacity];&#10;            for (int i = 0; i &lt; size; i++) {&#10;                newElements[i] = elements[i];&#10;            }&#10;            elements = newElements;&#10;            System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);&#10;        }&#10;&#10;        // 缩容&#10;        private void trim() {&#10;            int oldCapacity = elements.length;&#10;            int newCapacity = oldCapacity &gt;&gt; 1;&#10;            // 缩容和扩容的时机相乘不能等于一，不然会引发复杂度震荡&#10;            if (size &gt; (newCapacity) || oldCapacity &lt;= DEFAULT_CAPACITY) return;&#10;&#10;            E[] newElements = (E[]) new Object[newCapacity];&#10;            for (int i = 0; i &lt; size; i++) {&#10;                newElements[i] = elements[i];&#10;            }&#10;            elements = newElements;&#10;&#10;            System.out.println(oldCapacity + &quot;缩容为&quot; + newCapacity);&#10;        }&#10;&#10;        // 查看元素的索引&#10;        public int indexOf(E element) {&#10;            if (element == null) {&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (elements[i] == null) return i;&#10;                }&#10;            } else {&#10;                for (int i = 0; i &lt; size; i++) {&#10;                    if (element.equals(elements[i])) return i;&#10;                }&#10;            }&#10;            return ELEMENT_NOT_FOUND;&#10;        }&#10;&#10;        // 普通抛出异常&#10;        private void rangeCheck(int index) {&#10;            if (index &lt; 0 || index &gt;= size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 增加元素抛出异常,增加元素的index允许和当前容量一样,因为会增加扩容措施&#10;        private void rangeCheckForAdd(int index) {&#10;            if (index &lt; 0 || index &gt; size) {&#10;                outOfBounds(index);&#10;            }&#10;        }&#10;&#10;        // 抛出异常&#10;        private void outOfBounds(int index) {&#10;            throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#10;        }&#10;&#10;        // 重写toString方法,打印数组&#10;        public String toString() {&#10;            StringBuilder string = new StringBuilder();&#10;            string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);&#10;            for (int i = 0; i &lt; size; i++) {&#10;                if (i != 0) {&#10;                    string.append(&quot;, &quot;);&#10;                }&#10;                string.append(elements[i]);&#10;            }&#10;            string.append(&quot;]&quot;);&#10;            return string.toString();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        ArrayList&lt;Integer&gt; list = new ArrayList(10);&#10;        list.add(10);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.add(20);&#10;        list.remove(1);&#10;        System.out.println(list);&#10;    }&#10;}" description="数组 - 采用数组实现ArrayList - OYArrayListImplementByArray" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
  <template name="oyarray-remove-same-num-in-order" value="/*&#10; *给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&#10; * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&#10;示例 1:&#10;给定数组 nums = [1,1,2], &#10;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 &#10;你不需要考虑数组中超出新长度后面的元素。&#10;&#10;示例 2:&#10;给定 nums = [0,0,1,1,1,2,2,3,3,4],&#10;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&#10;你不需要考虑数组中超出新长度后面的元素。&#10; */&#10;&#10;public class Solution {&#10;    public static int removeDuplicates(int[] nums) {&#10;        if (nums.length == 0) return 0;&#10;        int i = 0;&#10;        for (int j = 1; j &lt; nums.length; j++) {&#10;            if (nums[j] != nums[i]) {&#10;                i++;&#10;                nums[i] = nums[j];&#10;            }&#10;        }&#10;        //printArray(nums);&#10;        return i + 1;&#10;    }&#10;&#10;    public static void printArray(int[] nums){&#10;        if(nums == null || nums.length &lt; 1){&#10;            return;&#10;        }&#10;        for (int i = 0;i &lt; nums.length;i++){&#10;            System.out.print(nums[i] + &quot; &quot;);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        int[] nums = {0,0,1,1,1,2,2,3,3,4};&#10;        removeDuplicates(nums);&#10;        //这里输出0 1 2 3 4 2 2 3 3 4&#10;        printArray(nums);&#10;    }&#10;}&#10;" description="数组 - 删除排序数组中的重复项 - OYArrayRemoveSameNumInOrder" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="OTHER" value="true" />
    </context>
  </template>
</templateSet>